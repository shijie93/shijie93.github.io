<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（七）]]></title>
    <url>%2F2017%2F07%2F03%2Fregex-7%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（五） 回溯引用上一节介绍了通过子表达式来把一组字符当成一个集合来进行重复和或操作等，本节我们来介绍子表达式的另一个重要的用途–定义回溯引用 同样的，我们通过一个场景，来引入回溯引用 &lt;LABEL1&gt;string1&lt;/LABEL1&gt; &lt;LABEL2&gt;string2&lt;/LABEL2&gt; &lt;LABEL3&gt;string3&lt;/LABEL3&gt; 以上内容是在HTML程序中的一处缩写，我们要求能够匹配每一个label标签以及匹配的结束标签 模式：&lt;LABEL[1-3]&gt;.*?&lt;/LABEL[1-3]&gt; 还记得在元字符*后面增加元字符?的目的码？这里可要防止它的“贪婪”哦~ 匹配上面的场景，发现我们的模式貌似没问题，在看看下面的场景 &lt;LABEL1&gt;string1&lt;/LABEL1&gt; &lt;LABEL1&gt;string2&lt;/LABEL2&gt; &lt;LABEL3&gt;string3&lt;/LABEL3&gt; 很明显第二行，开始标签和结束标签是不匹配的，这不是我们想要的匹配内容，但是我们的模式却无法那么“智能”，我们似乎还得增加一个限定，前后标签的级别是一样的才行。 老话重提，把我们想要的内容匹配到很容易，但是保证不能匹配到我们不想要的，往往会困难的多得多 回溯引用匹配还是上面的场景，我们需要以下两个步骤 匹配开始标签的数字，并记录 比较结束标签的数字是否和开始的相同，相同则匹配 简单地说，就是把前面匹配的内容作为引用，交给结束标签匹配。 模式：&lt;LABEL([1-3])&gt;.*?&lt;/LABEL\1&gt; 我们来仔细看一下这个模式 ([1-3]) 原先开始标签匹配的数字用小括号给包了起来 在结束标签本来匹配数字的地方，增加了一个\1 这是典型的一个回溯引用，通过()包裹的匹配内容，会在\1处作为模式部分再次的匹配，即保证了前后的一致性 回溯引用的定义：模式的后半部分引用前半部分中定义（匹配）的子表达式 同样的，\2、\3代表第二第三个子表达式。 \0 在很多实现里表示整个正则表达式，有些的问题也存在着：变化位置和添加内容，可能就不是我们原有的初衷（可以把这些引用想象成相对位置的一个引用，如果我在某个中间插入一个，或许会让引用前后对应混乱） 回溯引用-替换我们从第一节到目前，介绍的都是如何使用正则表达式进行搜索，其实，正则表达式的另一大领域或者说用途，就是来完成各种错综复杂的替换操作。 杀鸡焉用牛刀，简单的文本替换，当然不用正则表达式出马，正则表达式更适用于复杂的替换操作 马上我们要介绍的回溯引用的场景，就可以发挥出正则表达式真正的威力 我们来看一下下面的场景 0517-83966712 0571-54123245 010-78469123 上面是几个虚拟的电话号码，我们需要将区域号用（）括起来 匹配：(\d{3,4})(-\d{8}) 替换：(\1)\2 有一些编辑器需要写成 ($1)$2 将号码拆分成两个子表达式 0517 -83966712 两部分用括号包起来，作为子表达式，然后在替换的时候按照我们的需求，加上小括号。 这里我们可以分割成更细的几个子表达式，这样可以让我们进行更精细的控制哦~ 上面的替换只是举了一个简单的例子，但是核心思想是通过子表达式的回溯引用来达到替换的作用，让我们的替换工作更加的灵活和通用 大小写转换我们在替换的过程中，有时需要我们把匹配到的字符或者子表达式中的大小写进行转换，下面他们通过介绍一些元字符的使用和搭配，来完成这个场景 apple-favorite banana-hate 请将逗号前水果的名字转换成大写 匹配：(\w+)(-\w+) 替换：\U\1\E\2 我们在 \1左边添加了\U，右边添加了 \E，我们告诉模式，我们需要中间的字符小写转换成大写，是的，只需要这么做就可以了，是不是很方便？ 元字符 说明 \E 结束\L或者\U转换 \l 把下一个字符转换为小写 \L 把\L到\E之间的字符全部转换为小写 \u 把下一个字符转换为大写 \U 把\L到\E之间的字符全部转换为大写 总结本节我们主要介绍了子表达式的另一使用-回溯引用，以及他在匹配和替换中发挥的重要的作用，熟能生巧，希望读者能够多加练习，融会贯通 转载请说明出处 codingsj.com]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（六）]]></title>
    <url>%2F2017%2F07%2F02%2Fregex-6%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（五） 子表达式元字符和字符是正则表达式的基本构件，他们的使用方法已经在前面几个章节介绍过了，本节，我们翻开正则表达式的新章节–子表达式。通过子表达式，我们讲了解如何将正则表达式的模式进行分组和归类。 前面我们介绍过如何表达一个重复的字符，通过形如\b+、[a-z]{2,4}等方式，细心的读者可以发现，他们的共同点也是其局限性，就是只能表示重复模式前的那个字符，也就是说，单字符重复。下面我们通过一个例子，引入一个场景： 有一些文本短语类似 windows xp，很多的HTML程序员在编写文档时为了确保这些的短语在同一行中，会在windows 和 xp 之间增加非换行型字符 - &nbsp;，即non-breaking space。而不是普通的空格，例如下面的文本 I bought a new computer the day before yesterday, and the system is Windows&amp;nbsp;&amp;nbsp;XP, which is the operating system issued by Microsoft Corp。 我们找出文本中的非换行型字符&nbsp; 模式：&amp;nbsp;{2,} 我们的本意是匹配至少两个的&nbsp;，但是他不能满足我们的要求，因为他只能匹配形如&nbsp;;;的字符集合，而无法匹配&nbsp;&nbsp; 我们需要将&nbsp;识别成一个整体，即一个子表达式 子表达式可以看作是在一个更大的表达式里的一个表达式的整体，这种需求的目的是可以把某些字符当成一个独立的元素来使用 子表达式必须用()括起来，这里的左右括号也是元字符，匹配本身需要增加转移字符 再回来上面的场景，我们需要匹配至少两个的&nbsp;，利用子表达式的模式如下： (&amp;nbsp;){2,} 这个表达式可以满足我们的需求，(&nbsp;)看成了一个整体，通过{2,}来表示至少重复两次 在看下一个场景： The new computer has set broadband, and the IP is 192.168.123.45 我们需要匹配文本中的IP账号 模式：\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} 使用上一节所学的内容，我们通过元字符\d来代表数字，因为IP的每一级地址的范围为0~255，\d{1,3}可以满足我们的需求。能否运用子表达式的概念来简化这个模式呢？ 模式：(\d{1,3}\.){3}\d{1,3} 前三次重复包含着’.’，最后一次没有’.’哦~ 如果写成(\d{1,3}.){3}(\d{1,3})，这样可读性会相对高一些，但是可能对匹配操作的速度会有影响 子表达式是正则表达式里一个相当重要的概念，熟练地掌握子表达式可以帮助我们构建更完善的模式。关于子表达式的认识，我们有必要再通过一个场景来强调： 1993 is my birth year 我们需要匹配文本中的所有年份 模式：19|20\d{2} ‘|’是一个新的元字符，表示或的概念，我们的本意是要匹配19和20开头的年份，但是实际达成的效果是匹配19和20\d{2} 模式：(19|20)\d{2} 这个模式可以满足我们的需求，也是使用子表达式的另一个用途 关于子表达式的嵌套我们继续关注上面IP的那个场景，我们给出了一种模式： 模式：(\d{1,3}\.){3}\d{1,3} 通过这个模式，我们虽然可以包含所有有效的IP地址，但是很多无效的，也会被匹配到 记住，把我们想要的内容匹配到很容易，但是保证不能匹配到我们不想要的，往往会困难的多得多 我们刚才提到的，IP地址每一级的数字范围是0~255，我们可以总结出下面一些小的规则： 所有的一位数和二位数 百位为1的三位数 百位为2，十位为0~4的三位数 百位为2，十位为5，各位为0~5的三位数 按照上面的规则，我们重新来组织我们的模式 \d{1,2} 1\d{1,2} 2[0-4]\d 25[0-5] 模式：(((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5])).){3}((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5])) 好多的嵌套，是不是看的眼花，如果仔细看，只是各种小的子表达式通过元字符’|’的形式做的一个嵌套，所以，解剖一个负责的表达式，分析每一个子表达式的含义，往往是分析和构建正则表达式的基础 !!注意，上面的模式，在.前的几个子表达式组成了一个更大的子表达式，想想这是为什么 转载请说明出处哦~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（五）]]></title>
    <url>%2F2017%2F06%2F30%2Fregex-5%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（四） 位置匹配前面几节，我们主要介绍了使用各种各样的元字符使我们的模式能够满足重复匹配，至此，你可以解决很多问题了。下面通过一个场景来引出本节的主旨 The cat scattered his food all over the room. 我们需要找出所有“猫”的单词-cat： 模式：cat 是的，那只猫被我们找到了，可是它所做的事儿，也被我们”找到”了 – scattered 如何确保模式能够满足我们的需求，又不能找到我们不想要的结果，这往往是需要多加揣摩的 是的，我们虽然直接的用cat作为了我们的模式，但是cat毕竟可能出现在文本的任意地方，我们没有对他的位置进行任何的限定，这自然会”一网打尽”。 本节，我们主要介绍如何结合位置的一些小技巧，让我们的模式更加的健壮。 边界匹配-单词边界还是上面的场景，如果我们可以增加一个限定，找寻一个单词，单词的文本为”cat”，那就搞定啦。 在正则表达式中一个完整的单词，他的前后需要加上限定符’\b’ 模式：\bcat\b 使用单词边界的限定符来组成我们的模式，那么，这只坏坏的猫，终于被我们”抓到”了。 当然，\bcat表示cat开头的单词，cat\b表示以cat结尾的单词，如前面提到的，\B就代表不是单词的边界，可用来找寻多余的空格 边界匹配-字符串边界单词边界可以用来进行有关单词位置相关的匹配，字符串边界也有着类似的用途。开门见山： 字符串开头用’^’，字符串结尾用’$’。’^’这个元字符我们已经介绍过了，当时的含义是取非，不过，这必须当它在”[]”内并且紧挨着左边的方括号时，它才有取非的作用，在本节，他发挥着字符串开头限定的作用。 12345678&lt;url&gt;&lt;loc&gt;http://codingsj.com/2017/06/16/pc-no-network-rc/&lt;/loc&gt;&lt;lastmod&gt;2017-06-30T11:45:49.112Z&lt;/lastmod&gt;&lt;/url&gt;&lt;url&gt;&lt;loc&gt;http://codingsj.com/2017/06/16/pc-no-network-dnsmasq/&lt;/loc&gt;&lt;lastmod&gt;2017-06-30T11:45:16.180Z&lt;/lastmod&gt;&lt;/url&gt; 匹配标签loc内的内容 模式：^&lt;loc&gt;.*&lt;/loc&gt; ‘^’代表从行首开始匹配的字符串，看似正确的模式，读者是否能看出存在什么问题？ 可以在编辑器中尝试着匹配一下，尝试着用上一节介绍的内容解决这个问题吧，do it！ 思考一下，^.*$什么情况下得不到匹配 总结本节内容比较简单，量也不较少，但是要注意实践，很多问题都是在调试的时候出现的 转载请说明出处：http://codingsj.com/2017/06/30/regex-5/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（四）]]></title>
    <url>%2F2017%2F06%2F26%2Fregex-4%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（三） 重复匹配上一节，我们介绍了元字符的一些使用和事例，包括之前介绍的匹配纯文本等，都是单次匹配-每种模式只匹配一个字符。本节将要介绍如何使我们的模式能够匹配能够“重复利用”，事半功倍。下面我们来思考一个场景： www.baidu.com 如果我们要匹配以上格式的网址（AAA.BBB.CCC）,运用之前学到的知识，我们应该如何做到呢？ 模式：\w\w\w\.\w\w\w\w\w\.\w\w\w 很明显，这样不仅没有给我们带来便利，而且，这并不能代表上面所提到的网址格式。 本节，我们将会处理类似，某种匹配重复出现的问题，我们对出现次数并不做太多的考究，更重要的是能够帮助我们完成匹配 www.baidu.com www.hao123.com www.wobiande.gov 模式如下： 模式：\w+\.[\w\d]+\.\w+ 看完本节，你会立马理解上面这个模式的，我担保！ 至少匹配一次上面的场景中我们知道，两个”.”前后的字符走不可少，不可能存在www..com的网址对吧，所以，我们给予它重复的次数一定是不少于一次的。我们使用的元字符是“+” “+” 匹配一个或者多个字符，最简单的一种使用就是“b+”，这代表匹配至少一个“b”，它也可以有一些复杂的使用方式，例如我们之前提到的[a-z],它代表a,b,c…z的任意一个字符，如果我们要表示由不少于一个的小写字符组成，我们要怎么表示呢？[a-z]+,记住不要把+写到[]里，这只能表示单个字符+（类似像”.”,”+”这样的元字符，在[]内可以不用转义而表达它原本的含义，但是增加转义让人看上去更清晰明了） 细心的朋友可能发现了，[\w\d]+，“+”元字符也可以接在字符集合后，代表不止一次的集合内任意一个匹配 匹配任意次数“+”的使用场景是“起码得有一次”，下面介绍的是可以一次都没有，当然，它的范围是比”+”要大的，因为多了一个“零匹配”。那就是”*” “*”也是一个元字符，将它放在字符或者字符集合后面，就可以匹配该字符或者字符集合零次或者多次的情况 来看另一个场景： &lt;start&gt;123&lt;end&gt; &lt;start&gt;abc&lt;end&gt; &lt;start&gt;&lt;end&gt; 需要匹配每一组start和end，模式如下 &lt;start&gt;.*&lt;end&gt; 我们可以吧”*”理解成它之前的字符是可选的，但是”+”可以理解为它之前的字符是必选的，两者都是可以重复 0 or 1我们已经介绍了至少匹配一次 和 “可有可无” 的情况，那么，如果我既想要可有可无，有的时候只匹配单词呢？ “?”字符可以帮助我们达到这种效果 x现在我们介绍了”*”、”+”和”?”,请大家仔细体会其中的区别 看一下如下的场景： http://www.hao123.com https://shijie93.github.io 将这两个网址同事能够匹配 模式：https?://[\w.]+ “s?”表示此处的s可有可无，而且有的时候，只会出现一次 是否还记得上一节我们提到空白行的表示方法，在windows和linux的表现方式不同，我们可以通过”?”整合成同一种表现形式：[\r]?\n[\r]?\n 指定次数上面介绍的三个元字符+、*和？可以处理很多场景的问题，但是有一些情况下，他们有些力不从心，如何管控匹配的次数呢，这三个都不能很好的完成这个任务，看样子，我们又要解锁新的“技能了”。 {，}可以帮助我们解决这个问题 指定某个次数模式：[\w]{3} #匹配三次字母字符，加上中括号是为了增强可读性 如上所示，代表前面的字符或者字符集合匹配固定的次数 指定匹配区间模式：[\w]{3,6} #匹配三次到六次字母字符，加上中括号是为了增强可读性 如上所示，代表前面的字符或者字符集合匹配次数区间 设置匹配下限模式：[\w]{3,} #匹配三次以及三次以上字母字符，加上中括号是为了增强可读性 如上所示，代表前面的字符或者字符集合匹配次数区间，右边界可视为无穷大 贪婪的元字符先看下面这个场景： &lt;start&gt;abc&lt;end&gt; , &lt;start&gt;cba&lt;end&gt; 我们需要匹配每一对start和end，下面是匹配的模式： 模式：&lt;start&gt;.*&lt;end&gt; 请思考这是会如你所愿，匹配到想要的文本吗？ “.*”匹配一切，并且，贪婪的匹配一切，知道最后一次出现了它后面的模式片段，往往，这不是我们所需要的。 “+”,”*”都是贪婪型的元字符，他们并不会在第一次遇到后面的匹配时“停手”，而是不停的匹配知道最后一次的出现位置，就像一个吃货，不停的吃吃，知道吃饱吃不下为止。我们想要避免这种贪婪的情况，只需要在这些元字符后添加一个”?”就可以了。 模式：&lt;start&gt;.*?&lt;end&gt; 你再用上面的模式尝试匹配一下，发现可以满足我们的要求 上面提到过的设置匹配区间和匹配下限的情况，也可以在后面加一个元字符”?”，可以试试会发生什么 {3,6}?、{3,}? 总结介绍了这节，我们慢慢能够体会到正则表达式的神奇和高效了，别着急，更厉害的还在后面呢 装载请说明出处：http://codingsj.com/2017/06/26/regex-4/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（三）]]></title>
    <url>%2F2017%2F06%2F25%2Fregex-3%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（二） 元字符前面两节，我们学习已经多次提到了元字符（”.”,”[]”,”\”等），在正则表达式的语法中，元字符的种类和用途可谓是多种多样，纷繁复杂，有效的搭配元字符使用，能够使得模式更加的简单和高效。 代表本身-转义如果我们想要在模式中匹配元字符本身，需要在对应的元字符前增加“\”，例如 a[1]=1 b[2]=2 想要匹配如上的数组： 模式：[ab]\[[0-9]\] 所有的元字符前都可以通过在前面增加反斜杠来代表它本身，包括反斜杠自己 “看不见”的字符在待匹配的字符串中，除了那些可见的字符数字和符号，还有一些“看不见”的字符，利用好这些字符，可以很好的帮助我们建立兼容性高，准确性高的匹配模式，下面举一些例子来“显现”这些字符： 看不见的字符 说明 \b 回退一个字符（Backspace键） \f 换页符 \n 换行符 \r 回车符 \t 制表符（Tab键） \v 垂直制表符 下面举个例子 白日依山径 黄河入海流 欲穷千里目 更上一层楼 如何匹配这里的空白行 模式：\r\n\r\n 其实我在输入这行空白行时，就是连续输入了两个回车，这与实际相同 在window系统中，\r\n是一行的结尾标签，但是在Unix和linux内，只使用\n来结束当前行，所以，此例在Unix下，可以替换成\n\n。后面介绍替换的时候，我们可以通过这类的匹配来做一些类似删除空白行，删除无用信息行的操作，这很实用 注意像 “[“,”.”等字符，加上反斜杠，代表的是字符本身，而像n,f,t等，加上反斜杠，却能够代表特殊的含义.这些需要我们注意使用，不要混淆 特定字符集合上一节我们提到过，如果要表示一堆数字的集合，可以用[0-9]来表示,其实还有一种形式来表示这一些集合，下面直接给出一些： 模式 说明 \d 0-9 \D 非0-9 \w 任何的字母 \W 非任何字母 \s 任何一个“看不见”的字符 \S 非任何一个“看不见”的字符 \s 即表示 \f,\t,\n 等之前提到的那些空白字符 我们已经遇到很多同一种问题可以用多种方法来解决的例子了，是不是越简单越好呢，有时候，越复杂，或许越经得住“考验”，如果我们要构建一个更完善，更兼容的模式，也许我们需要花时间，将他设计的更复杂一些吧。 总结本节针对元字符进行了分类的介绍，包括转义字符，空白字符已经一些特定的字符集合，可通过自己拟定一些场景，加深理解 转载请说明出处：http://codingsj.com/2017/06/25/regex-3/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（二）]]></title>
    <url>%2F2017%2F06%2F25%2Fregex-2%2F</url>
    <content type="text"><![CDATA[回顾上一篇一个神奇高效的工具-正则表达式（一） 多个字符的匹配上一节，我们介绍了如何匹配纯文本和任意字符。但是绝大多数情况，我们匹配的模式是既不是固定的某一个字符或者字符串，也不是说任意字符都可以，通常我们会去匹配我们指定范围的字符集合，本节会着重地介绍字符集合的匹配模式。 多选一指定多选一先看一下如下的场景： aa ba cc dd 找出所有的以a为结尾的字符 模式：.a 此时，如果在待匹配中增加一个ea，但是你此时仍然只想找出aa和ba，使用任意字符就不合适了，这里介绍元字符的成员 模式：[ab]a 元字符’[‘ 和 ‘]’，在使用’[‘ 和 ‘]’定义的字符集合里，匹配的结果会任意选择其中一个作为匹配的文本。 [ab]a并不是最完善的匹配，如果我们增加一个bac，那么也会被匹配。有时候，验证某个模式能不能得到预期的匹配并不难，但是验证它能不能匹配到你不想要的东西就比较困难了。 再举一个类似的例子 Apple is a fruit, my dad likes apple. 找出所有的苹果的单词 模式：[Aa]pple 这样，大写小写开头的苹果单词都会被匹配 区间多选一上面说到的指定集合多选一，存在一个问题，就是集合过多的时候，逐个枚举会显得很笨重，这样也就失去了正则表达式的初衷。接下来我们介绍一种利用区间来指定集合的模式看下面这个例子： 1.c 2.c 3.c 4.c 5.c 8.c 9.c a.c b.c 匹配所有以数字为文件名的c文件 模式：[0123456789]\.c 汗，笨重的写法总是让人很反感，类似数字集合，大写字母集合，小写字母集合，都是很常见的匹配模式，当然有更简单的写法 模式：[0-9] [A-Z] [a-z] [A-H] 模式[0-9] 完全等价于 [0123456789] ，其他类推，当然也可以组合使用[0-9A-Za-z]代表所有的数字和字母集合，很明显的 ‘-‘也是元字符，但是中能在’[‘ 和 ‘]’之间进行使用 取非匹配匹配可以指定我需要什么，当然也可以指定我不需要什么了，这时往往需要取非匹配模式。举个例子： 0B 1k 2M 3G 4T 匹配除了M级别的内容大小 模式：.[BMGT] 正如前面所说，正则表达式往往有很多种方法来获得你想要的结果 我们也可以用元字符’^’来表示取非，即我不要匹配某个字符，如下： 模式：.[^M] ^常常存在于集合中，而且取非的内容是整个集合,例如：[^a-z]为不匹配所有小写字母 总结本节我们介绍了多对一的匹配以及取非模式,元字符’[‘，’]’，’-‘和’^’,下一节，我们会着重介绍使用元字符的模式 转载请说明出处：http://codingsj.com/2017/06/25/regex-2/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇高效的工具-正则表达式（一）]]></title>
    <url>%2F2017%2F06%2F25%2Fregex-1%2F</url>
    <content type="text"><![CDATA[什么是正则表达式正则表达式是用来匹配和处理文本的字符串，是用正则表达式语言创建的。一般使用正则表达式的场景无外乎两个： 查找特定的信息（搜索） 查找并编辑特定的信息（替换） 即搜索和替换 正则表达式并不是一种完备的语言，他是内置在其他语言中的“迷你”的语言，我们可以把它看作是一个工具，一个神奇并且高效的工具。 如何学习正则表达式我们说正则表达式是一门“语言”，那么一门语言就一定有属于它的“语法”。学习正则表达式，需要学习它的语法，这是基础和根本，但是正则表达式真正的难度在于如何在合适的场景用所学的语法（合适的语法，因为学习了正则表达式之后，很多问题会有很多种方法去解决，有的兼容性好，有的简单，有的比较快达成，那么问题如何去寻找最合适的方法，往往是需要很多的实践和尝试的）。学以致用，实践是检验真理的唯一标准，所以，大家在日常的编程工作中，一定要去敢于使用正则表达式，不断的锻炼自己，正如某位前辈曾经说的: 当一个问题，你决定使用正则表达式来解决的时候，很好，那么你现在面临的是两个问题了 匹配无论是查找还是替换，最先要做到也是最基本的，就是匹配你想要处理的内容，匹配全了，我们的查找才能全面，替换才能准确，匹配不到所有的内容或者匹配的内容不仅仅包括你的目标，那么都会成为一个错误的使用。 纯文本匹配日常我们在使用编辑器时，最常用的就是使用纯文本进行匹配： welcome to guangzhou 如果想要找到所有的guangzhou，那么只需要使用“guangzhou”进行匹配即可那么如果你在输入匹配内容的时候，并不知道文章中的guang zhou是否存在大写字母，如果你是入了”GuangZhou”,上面的内容还能匹配到吗？答案是否，正则表达式是对大小写敏感的“语言”（某些环境下，可以使用例如i的选项来ignore大小写），但是正则表达式的很多技巧，都可以完美的解决这个问题，这个我们在接下来的内容中，会详细的进行介绍 任意字符的匹配正则表达式的神奇，绝对不是体现在纯文本的匹配呀！下面我们来介绍他的七十二般变化之一-如何体现任意字符的匹配。 I am in class-1 Li ming is in class-4 My brother is in class-7 我们如何在以上文本中，找出所有的班级的集合呢？正则表达式中有一个符号，可以匹配任意的字符： 符号 . 所以我们只需要输入匹配文本： 模式：class-. 就可以成功的匹配到文本中的所有班级信息（有心的同学，应该注意到，如果班级不止一位数，这个匹配的样式还可行吗？可以思考一下） 如何匹配.接着上面的内容，我们领略到了”.”的强大，那么，如果我们的待匹配文本中，我们需要匹配它本身,应该怎么做呢？我们应该告诉处理器，我们要找它本人 2.4 214 如果我们要匹配数字2.4，你需要在.前面增加一个\（反斜杠,\是一个元字符,表示它后面的字符有特殊的含义，不是他本身的含义（本身含义即为匹配任意字符）） 模式：2\.4 哈哈，有时候”\”也身不由己，需要匹配他自身的时候： 模式：\\ 总结模式（正则表达式简称）可以由纯文本或者一些元字符组成，元字符前增加\，可以匹配它本身 转载请说明出处：http://codingsj.com/2017/06/25/regex-1/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 重启后恢复Latin输入法的问题]]></title>
    <url>%2F2017%2F06%2F22%2Finput-method-latin%2F</url>
    <content type="text"><![CDATA[背景前几天在配置一个客户需求，是要定制化的默认输入法，当时增加了一些配置的逻辑后，验证了下烧录后的开机默认输入法，发现没什么问题，然后就编译软件给了测试。等到测试结束后，被告知在重启后，输入法没有保留关机前的配置，被改成了Latin输入法。当时觉得一头雾水，为什么重启之后，这个输入法会改变呢。 循序渐进后来请应用的同事一起来看问题，发现在重启机器之后，settings.db的数据库发生了变化。shettings.db数据库是在第一次开机时，系统生成的一个数据库，里面维护着和setting有关的数据配置，我们的默认配置输入法，在数据库中的name 为 DEFAULT_INPUT_METHOD，初次写入是在 DatabaseHelper.java 中进行维护。 可是在重启之后，读了这个数据库的 DEFAULT_INPUT_METHOD的value，发现被改成了Latin输入法的value，难道是有什么地方改动了数据库？ 突破口如果数据库被改动了，那么就先从修改数据库的最低端，直接操作数据库的地方找起，下面是对数据库操作的函数123456789//Android/frameworks/base/core/java/com/android/internal/inputmethod/InputMethodUtils.javapublic void putSelectedInputMethod(String imeId) &#123; if (DEBUG) &#123; Slog.d(TAG, "putSelectedInputMethodStr: " + imeId + ", " + mCurrentUserId); &#125; Settings.Secure.putStringForUser( mResolver, Settings.Secure.DEFAULT_INPUT_METHOD, imeId, mCurrentUserId); // 将传进来的输入法的ID imeID 写入到settings.db表名为DEFAULT_INPUT_METHOD内&#125; 接下来，我们就看一下哪里调用了他吧 增加打印然后是将近大半天的打印追踪，具体的方法大家懂得 找到根源终于在关机的时候，找到了修改数据库的操作123456789101112131415161718192021222324252627282930313233343536373839404142//Android/frameworks/base/services/core/java/com/android/server/InputMethodManagerService.java class MyPackageMonitor extends PackageMonitor &#123; private boolean isChangingPackagesOfCurrentUser() &#123; final int userId = getChangingUserId(); final boolean retval = userId == mSettings.getCurrentUserId(); if (DEBUG) &#123; if (!retval) &#123; Slog.d(TAG, "--- ignore this call back from a background user: " + userId); &#125; &#125; return retval; &#125; @Override public boolean onHandleForceStop(Intent intent, String[] packages, int uid, boolean doit) &#123; if (!isChangingPackagesOfCurrentUser()) &#123; return false; &#125; synchronized (mMethodMap) &#123; String curInputMethodId = mSettings.getSelectedInputMethod(); final int N = mMethodList.size(); if (curInputMethodId != null) &#123; for (int i=0; i&lt;N; i++) &#123; InputMethodInfo imi = mMethodList.get(i); if (imi.getId().equals(curInputMethodId)) &#123; for (String pkg : packages) &#123; if (imi.getPackageName().equals(pkg)) &#123; if (!doit) &#123; return true; &#125; selectedInputMethodAndSubtypeLocked(""); chooseNewDefaultIMELocked(); // &lt;&lt;&lt;------ 这里重新选择了默认的输入法 return true; &#125; &#125; &#125; &#125; &#125; &#125; return false; &#125; &#125; 我们先来看一下是哪里修改了数据库，强制的写成了Latin语言的输入法的 chooseNewDefaultIMELocked12345678910111213private boolean chooseNewDefaultIMELocked() &#123; final InputMethodInfo imi = InputMethodUtils.getMostApplicableDefaultIME(mSettings.getEnabledInputMethodListLocked()); // &lt;&lt;&lt;------ 这里就是罪魁祸首 if (imi != null) &#123; if (DEBUG) &#123; Slog.d(TAG, "New default IME was selected: " + imi.getId()); &#125; resetSelectedInputMethodAndSubtypeLocked(imi.getId()); // &lt;&lt;&lt;------ 进一步设置 return true; &#125; return false;&#125; chooseNewDefaultIMELocked 就是锁定一个默认的输入法，getMostApplicableDefaultIME就是获取了Latin的输入法123456789101112131415161718192021public static InputMethodInfo getMostApplicableDefaultIME(List&lt;InputMethodInfo&gt; enabledImes) &#123; if (enabledImes == null || enabledImes.isEmpty()) &#123; return null; &#125; // We'd prefer to fall back on a system IME, since that is safer. int i = enabledImes.size(); int firstFoundSystemIme = -1; while (i &gt; 0) &#123; i--; final InputMethodInfo imi = enabledImes.get(i); if (InputMethodUtils.isSystemImeThatHasEnglishKeyboardSubtype(imi) // &lt;&lt;&lt;------ 如果Latin是存在于输入法列表中的，直接返回Latin的输入法 ，否则，选择表中的第一个输入法 &amp;&amp; !imi.isAuxiliaryIme()) &#123; return imi; &#125; if (firstFoundSystemIme &lt; 0 &amp;&amp; InputMethodUtils.isSystemIme(imi) &amp;&amp; !imi.isAuxiliaryIme()) &#123; firstFoundSystemIme = i; &#125; &#125; return enabledImes.get(Math.max(firstFoundSystemIme, 0)); &#125; 哈哈，Google的设计有时候真的让人很佩服，强制设置了Latin，毕竟是自己开发的啊。如果客户删除了Latin输入法，那就选用表中的第一个遍历到的就好 函数返回后，调用 resetSelectedInputMethodAndSubtypeLocked(imi.getId())123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private void resetSelectedInputMethodAndSubtypeLocked(String newDefaultIme) &#123; InputMethodInfo imi = mMethodMap.get(newDefaultIme); int lastSubtypeId = NOT_A_SUBTYPE_ID; // newDefaultIme is empty when there is no candidate for the selected IME. if (imi != null &amp;&amp; !TextUtils.isEmpty(newDefaultIme)) &#123; String subtypeHashCode = mSettings.getLastSubtypeForInputMethodLocked(newDefaultIme); if (subtypeHashCode != null) &#123; try &#123; lastSubtypeId = InputMethodUtils.getSubtypeIdFromHashCode( imi, Integer.valueOf(subtypeHashCode)); &#125; catch (NumberFormatException e) &#123; Slog.w(TAG, "HashCode for subtype looks broken: " + subtypeHashCode, e); &#125; &#125; &#125; setSelectedInputMethodAndSubtypeLocked(imi, lastSubtypeId, false); // &lt;&lt;&lt;------将传进来的imi设置&#125; private void setSelectedInputMethodAndSubtypeLocked(InputMethodInfo imi, int subtypeId, boolean setSubtypeOnly) &#123; // Update the history of InputMethod and Subtype mSettings.saveCurrentInputMethodAndSubtypeToHistory(mCurMethodId, mCurrentSubtype); mCurUserActionNotificationSequenceNumber = Math.max(mCurUserActionNotificationSequenceNumber + 1, 1); if (DEBUG) &#123; Slog.d(TAG, "Bump mCurUserActionNotificationSequenceNumber:" + mCurUserActionNotificationSequenceNumber); &#125; if (mCurClient != null &amp;&amp; mCurClient.client != null) &#123; executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO( MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER, mCurUserActionNotificationSequenceNumber, mCurClient)); &#125; // Set Subtype here if (imi == null || subtypeId &lt; 0) &#123; mSettings.putSelectedSubtype(NOT_A_SUBTYPE_ID); mCurrentSubtype = null; &#125; else &#123; if (subtypeId &lt; imi.getSubtypeCount()) &#123; InputMethodSubtype subtype = imi.getSubtypeAt(subtypeId); mSettings.putSelectedSubtype(subtype.hashCode()); mCurrentSubtype = subtype; &#125; else &#123; mSettings.putSelectedSubtype(NOT_A_SUBTYPE_ID); // If the subtype is not specified, choose the most applicable one mCurrentSubtype = getCurrentInputMethodSubtypeLocked(); &#125; &#125; // Workaround. // ASEC is not ready in the IMMS constructor. Accordingly, forward-locked // IMEs are not recognized and considered uninstalled. // Actually, we can't move everything after SystemReady because // IMMS needs to run in the encryption lock screen. So, we just skip changing // the default IME here and try cheking the default IME again in systemReady(). // TODO: Do nothing before system ready and implement a separated logic for // the encryption lock screen. // TODO: ASEC should be ready before IMMS is instantiated. if (mSystemReady &amp;&amp; !setSubtypeOnly) &#123; // Set InputMethod here mSettings.putSelectedInputMethod(imi != null ? imi.getId() : "");// &lt;&lt;&lt;------ 这里就是写数据库的直接操作了 &#125;&#125; 好吧，终于看到了写数据库的操作了 等等，我们是不是漏了什么，到底什么情况下会进入到这里呢？我们再看一下刚才的上下文123456789101112131415161718192021222324252627282930313233343536373839404142 class MyPackageMonitor extends PackageMonitor &#123; // &lt;&lt;&lt;------ 广播类 private boolean isChangingPackagesOfCurrentUser() &#123; final int userId = getChangingUserId(); final boolean retval = userId == mSettings.getCurrentUserId(); if (DEBUG) &#123; if (!retval) &#123; Slog.d(TAG, "--- ignore this call back from a background user: " + userId); &#125; &#125; return retval; &#125; @Override public boolean onHandleForceStop(Intent intent, String[] packages, int uid, boolean doit) &#123; // &lt;&lt;&lt;------ 回调函数onHandleForceStop if (!isChangingPackagesOfCurrentUser()) &#123; return false; &#125; synchronized (mMethodMap) &#123; String curInputMethodId = mSettings.getSelectedInputMethod(); final int N = mMethodList.size(); if (curInputMethodId != null) &#123; for (int i=0; i&lt;N; i++) &#123; InputMethodInfo imi = mMethodList.get(i); if (imi.getId().equals(curInputMethodId)) &#123; for (String pkg : packages) &#123; if (imi.getPackageName().equals(pkg)) &#123; if (!doit) &#123; return true; &#125; selectedInputMethodAndSubtypeLocked(""); chooseNewDefaultIMELocked(); return true; &#125; &#125; &#125; &#125; &#125; &#125; return false; &#125; &#125;&#125; 其中有两个比较关键的元素 PackageMonitor 和 onHandleForceStop PackageMonitorPackageMonitor类继承了 BroadcastReceiver 的类，PackageMonitor是一个内部API，并且它实际上是一个BroadcastReceiver。主要用来监听package的安装，卸载，重启等动作，具体的类如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class PackageMonitor extends android.content.BroadcastReceiver &#123; static &#123; // 注册监听了如下的广播intent action sPackageFilt.addAction(Intent.ACTION_PACKAGE_ADDED); sPackageFilt.addAction(Intent.ACTION_PACKAGE_REMOVED); sPackageFilt.addAction(Intent.ACTION_PACKAGE_CHANGED); sPackageFilt.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); sPackageFilt.addAction(Intent.ACTION_PACKAGE_RESTARTED); sPackageFilt.addAction(Intent.ACTION_UID_REMOVED); sPackageFilt.addDataScheme("package"); sNonDataFilt.addAction(Intent.ACTION_UID_REMOVED); sNonDataFilt.addAction(Intent.ACTION_USER_STOPPED); sExternalFilt.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE); sExternalFilt.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE); &#125; // 下面列举其中一些回调函数 public void onPackageAdded(String packageName, int uid) &#123; &#125; public void onPackageRemoved(String packageName, int uid) &#123; &#125; public void onPackageRemovedAllUsers(String packageName, int uid) &#123; &#125; public void onPackageUpdateStarted(String packageName, int uid) &#123; &#125; public void onPackageUpdateFinished(String packageName, int uid) &#123; &#125; public boolean onHandleForceStop(Intent intent, String[] packages, int uid, boolean doit) &#123; // 这个不就是我们上面遇到的函数吗，重写了我们的数据库 return false; &#125; public void onHandleUserStop(Intent intent, int userHandle) &#123; &#125; public void onUidRemoved(int uid) &#123; &#125; public void onPackagesAvailable(String[] packages) &#123; &#125; public void onPackagesUnavailable(String[] packages) &#123; &#125;&#125;回调函数 onHandleForceStop 即为 之前修改了数据库得到函数方法载体 onHandleForceStop看着这个函数，我想大家已经有了初步的定位，是的，就是在应用强制退出的时候，会发送action ACTION_PACKAGE_RESTARTED 并调用 onHandleForceStop。 是的，在重启的时候，Android会强制关闭正在后台运行的输入法的服务，导致回调此处，进而牵一发而动全身，将默认输入法的数据库改掉了。 其实这只是一个大致的流程，中间有很多机制，很多细节，日后学足，学精之后，必会回来填补漏洞 修复知道了来龙去脉了，修改当然就变得简单了，我们只需要让他将latin改成我们数据库中写入的即可，下面是修改的方法，经供参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 @Override public boolean onHandleForceStop(Intent intent, String[] packages, int uid, boolean doit) &#123; if (!isChangingPackagesOfCurrentUser()) &#123; return false; &#125; synchronized (mMethodMap) &#123; String curInputMethodId = mSettings.getSelectedInputMethod(); final int N = mMethodList.size(); if (curInputMethodId != null) &#123; for (int i=0; i&lt;N; i++) &#123; InputMethodInfo imi = mMethodList.get(i); if (imi.getId().equals(curInputMethodId)) &#123; for (String pkg : packages) &#123; if (imi.getPackageName().equals(pkg)) &#123; if (!doit) &#123; return true; &#125; InputMethodInfo defaultInputMethodInfo = null; InputMethodManager imm = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE); final List&lt;InputMethodInfo&gt; methodList = imm.getEnabledInputMethodList(); String defaultInputMethod = android.provider.Settings.Secure.getString(mContext.getContentResolver(), android.provider.Settings.Secure.DEFAULT_INPUT_METHOD); for (InputMethodInfo inputMethodInfo : methodList) &#123; if(!TextUtils.isEmpty(inputMethodInfo.getId()) &amp;&amp; inputMethodInfo.getId().equals(defaultInputMethod)) &#123; defaultInputMethodInfo = inputMethodInfo; &#125; &#125; resetSelectedInputMethodAndSubtypeLocked(""); mychooseNewDefaultIMELocked(defaultInputMethodInfo); return true; &#125; &#125; &#125; &#125; &#125; &#125; return false; &#125;private boolean mychooseNewDefaultIMELocked(InputMethodInfo imi) &#123; if (imi != null) &#123; if (DEBUG) &#123; Slog.d(TAG, "New default IME was selected: " + imi.getId()); &#125; Slog.e(TAG, "shijie 20"); resetSelectedInputMethodAndSubtypeLocked(imi.getId()); return true; &#125; return chooseNewDefaultIMELocked(); &#125; 重新构建一个函数，传入从表中读取的默认输入法即可 这个问题终于有了着落，八错八错]]></content>
      <categories>
        <category>Android system</category>
      </categories>
      <tags>
        <tag>Android input method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 原生AP关闭流程解析]]></title>
    <url>%2F2017%2F06%2F20%2Fwifi-softap-stop%2F</url>
    <content type="text"><![CDATA[回顾打开流程打开流程可以在510 原生AP启动和关闭流程解析知悉，了解了打开流程，会对关闭的过程有一个大致的思路。 关闭流程代码解析当我们在Setting菜单中打卡原生AP的开关后，会执行如下代码12345678910111213//Android/packages/apps/Settings/src/com/android/settings/TetherSettings.javapublic boolean onPreferenceChange(Preference preference, Object value) &#123; boolean enable = (Boolean) value; if (enable) &#123; //想要打开 startProvisioningIfNecessary(WIFI_TETHERING); //WIFI_TETHERING 通过wifi进行热点的分享 &#125; else &#123; //想要关闭 if (isProvisioningNeeded(mProvisionApp)) &#123; TetherService.cancelRecheckAlarmIfNecessary(getActivity(), WIFI_TETHERING); &#125; mWifiApEnabler.setSoftapEnabled(false); //进入wifiApEnabler 调用 setSoftapEnabled &#125; return false;&#125; 来看一下mWifiApEnabler.setSoftapEnabled(false)1234567891011121314151617181920212223242526272829303132333435363738//Android/packages/apps/Settings/src/com/android/settings/wifi/WifiApEnabler.java public void setSoftapEnabled(boolean enable) &#123; final ContentResolver cr = mContext.getContentResolver(); /** * Disable Wifi if enabling tethering */ int wifiState = mWifiManager.getWifiState();//获取wifi状态 if (enable &amp;&amp; ((wifiState == WifiManager.WIFI_STATE_ENABLING) || (wifiState == WifiManager.WIFI_STATE_ENABLED))) &#123; mWifiManager.setWifiEnabled(false);// 关闭WIFI Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 1);// 记录WIIF状态 &#125; if (mWifiManager.setWifiApEnabled(null, enable)) &#123; //进入 WifiManager 调用 setSoftapEnabled if (mSwitch != null) &#123; /* Disable here, enabled on receiving success broadcast */ mSwitch.setEnabled(false); &#125; &#125; else &#123; if (mSwitch != null) &#123; mSwitch.setSummary(R.string.wifi_error); &#125; &#125; /** * If needed, restore Wifi on tether disable */ if (!enable) &#123; int wifiSavedState = 0; try &#123; wifiSavedState = Settings.Global.getInt(cr, Settings.Global.WIFI_SAVED_STATE);//获取保存的wifi状态 &#125; catch (Settings.SettingNotFoundException e) &#123; ; &#125; if (wifiSavedState == 1) &#123; mWifiManager.setWifiEnabled(true); //恢复wifi为开启的状态 Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 0);//修改状态 &#125; &#125; &#125; 执行 mWifiManager.setWifiApEnabled(null, enable)123456789//Android/frameworks/base/wifi/java/android/net/wifi/WifiManager.java public boolean setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) &#123; try &#123; mService.setWifiApEnabled(wifiConfig, enabled); // 通过AIDL return true; &#125; catch (RemoteException e) &#123; return false; &#125; &#125; 通过AIDL，执行WifiServiceImpl.setWifiApEnabled(null,enabled)123456789101112131415//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.javapublic void setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) &#123; enforceChangePermission(); ConnectivityManager.enforceTetherChangePermission(mContext); UserManager um = UserManager.get(mContext); if (um.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) &#123; throw new SecurityException("DISALLOW_CONFIG_TETHERING is enabled for this user."); &#125; // null wifiConfig is a meaningful input for CMD_SET_AP if (wifiConfig == null || wifiConfig.isValid()) &#123; //wifiConfig可以是空 mWifiController.obtainMessage(CMD_SET_AP, enabled ? 1 : 0, 0, wifiConfig).sendToTarget();//发送CMD_SET_AP的消息给 WifiController &#125; else &#123; Slog.e(TAG, "Invalid WifiConfiguration"); &#125; &#125; enabled=false所以CMD_SET_AP消息发出，并且参数为 0 因为关闭热点之前，wificontroller的状态机的状态是停留在 mApEnabledState，下面是此状态的代码12345678910111213141516171819202122232425262728293031323334class ApEnabledState extends State &#123; @Override public boolean processMessage(Message msg) &#123; switch (msg.what) &#123; case CMD_AIRPLANE_TOGGLED: if (mSettingsStore.isAirplaneModeOn()) &#123; mWifiStateMachine.setHostApRunning(null, false); transitionTo(mApStaDisabledState); &#125; break; case CMD_SET_AP: // 关闭热点 if (msg.arg1 == 0) &#123; // 0 为 关闭 mWifiStateMachine.setHostApRunning(null, false); // 进入wifistatemachine状态机，执行关闭ap的流程 transitionTo(mApStaDisabledState); &#125; break; case CMD_WIFI_TOGGLED: mWifiStateMachine.setHostApRunning(null, false); transitionTo(mApStaDisabledState); break; default: return NOT_HANDLED; &#125; return HANDLED; &#125; &#125;public void setHostApRunning(WifiConfiguration wifiConfig, boolean enable) &#123; if (enable) &#123; sendMessage(CMD_START_AP, wifiConfig); &#125; else &#123; sendMessage(CMD_STOP_AP); &#125; &#125; 执行mWifiStateMachine.setHostApRunning(null, false); false为关闭，此代码会向wifistatemachine发送消息 CMD_STOP_AP，同样，wifistatemachine的状态机原先是在mSoftApStartedState12345678910111213141516171819202122232425262728293031323334353637class SoftApStartedState extends State &#123; @Override public boolean processMessage(Message message) &#123; logStateAndMessage(message, getClass().getSimpleName()); switch(message.what) &#123; case CMD_STOP_AP: // 关闭热点 if (DBG) log("Stopping Soft AP"); /* We have not tethered at this point, so we just shutdown soft Ap */ try &#123; mNwService.stopAccessPoint(mInterfaceName); // 通过 networkmanagementservice 发送命令 &#125; catch(Exception e) &#123; loge("Exception in stopAccessPoint()"); &#125; setWifiApState(WIFI_AP_STATE_DISABLED); //发送广播 WIFI_AP_STATE_DISABLED transitionTo(mInitialState); // 恢复初始状态 mInitialState break; case CMD_START_AP: // Ignore a start on a running access point break; // Fail client mode operation when soft AP is enabled case CMD_START_SUPPLICANT: loge("Cannot start supplicant with a running soft AP"); setWifiState(WIFI_STATE_UNKNOWN); break; case CMD_TETHER_STATE_CHANGE: TetherStateChange stateChange = (TetherStateChange) message.obj; if (startTethering(stateChange.available)) &#123; transitionTo(mTetheringState); &#125; break; default: return NOT_HANDLED; &#125; return HANDLED; &#125;&#125; 执行 mNwService.stopAccessPoint(mInterfaceName); 进入 NetworkManagementService123456789public void stopAccessPoint(String wlanIface) &#123; mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG); try &#123; mConnector.execute("softap", "stopap"); // 发送到commandlistener wifiFirmwareReload(wlanIface, "STA"); // mConnector.execute("softap", "fwreload", wlanIface, mode); &#125; catch (NativeDaemonConnectorException e) &#123; throw e.rethrowAsParcelableException(); &#125; &#125; 我们先来看一下mConnector.execute(“softap”, “stopap”);12345678910111213141516171819int CommandListener::SoftapCmd::runCommand(SocketClient *cli,int argc, char **argv)&#123; rc = sSoftapCtrl-&gt;stopSoftap();&#125;int SoftapController::stopSoftap() &#123; if (mPid == 0) &#123; ALOGE("SoftAP is not running"); return ResponseCode::SoftapStatusResult; &#125; ALOGD("Stopping the SoftAP service..."); kill(mPid, SIGTERM); // 杀死softap的进程 waitpid(mPid, NULL, 0); mPid = 0; ALOGD("SoftAP stopped successfully"); usleep(AP_BSS_STOP_DELAY); return ResponseCode::SoftapStatusResult;&#125; 首先杀死 执行hostapd 建立的进程，下面 执行上面的 wifiFirmwareReload(wlanIface, “STA”) 来将固件重载到STA模式（打开AP时将之重载为了AP，现还原） 此时，softap即关闭]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>Android softap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 目录的权限剖析]]></title>
    <url>%2F2017%2F06%2F16%2Flinux-directory-authority%2F</url>
    <content type="text"><![CDATA[一般而言，在linux中，文件的权限分为读，写和执行，顾名思义，读即为读取文件的信息和内容，写即为改变文件的内容和信息，执行，如果文件可执行的话，可以当做一个二进制文件运行。目录，作为linux中的另一种文件形式，本身也有读，写和执行三种属性，那么这与目录又有什么关系呢 文本和目录123456shijie930806@os05:test$ lltotal 12drwxr-xr-x 3 shijie root 4096 Jun 16 19:52 ./drwxrwx--- 25 shijie root 4096 Jun 16 19:47 ../drwxrwx--- 2 shijie shijie 4096 Jun 16 19:38 direct/-rw-r--r-- 1 shijie root 0 Jun 16 19:52 file 此处母目录test的权限为rwx 权限为d——-当前命令行的执行人为user：shijie 打开目录 –失败 查看目录 –失败 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为dr——当前命令行的执行人为user：shijie 打开目录 –失败 查看目录 –只能读取到目录中的文件名，文件信息无法获得 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为d-w—–当前命令行的执行人为user：shijie 打开目录 –失败 查看目录 –失败 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为d–x—-当前命令行的执行人为user：shijie 打开目录 –成功 查看目录 –失败 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为drw—–当前命令行的执行人为user：shijie 打开目录 –失败 查看目录 –只能读取到目录中的文件名，文件信息无法获得 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为dr-x—-当前命令行的执行人为user：shijie 打开目录 –成功 查看目录 –成功 创建文件 –失败 删除文件 –失败 删除目录 –失败 删除空目录 –成功 权限为d-wx—-当前命令行的执行人为user：shijie 打开目录 –成功 查看目录 –失败 创建文件 –成功 删除文件 –成功 删除目录 –失败 删除空目录 –成功 权限为drwx—-当前命令行的执行人为user：shijie 打开目录 –成功 查看目录 –成功 创建文件 –成功 删除文件 –成功 删除目录 –成功 删除空目录 –成功 结论 打开目录，必须有可执行的权限 查看目录内的文件名相当于文本文件的读取内容，至少需要可读的权限 查看目录内文件的所有信息，至少需要同时有可读和可执行的权限 在目录内创建文件，至少需要同时有可写和可执行的权限 删除目录内的文件，至少需要同时有可写和可执行的权限 删除非空的目录，必须具有所有的权限 删除空目录，与母目录的权限有关，同上]]></content>
      <categories>
        <category>linux shell</category>
      </categories>
      <tags>
        <tag>linux shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一网通PC无法解析内网域名-Dns上游服务器的动态配置]]></title>
    <url>%2F2017%2F06%2F16%2Fpc-no-network-rc%2F</url>
    <content type="text"><![CDATA[问题由来前段时间，公司的一款产品，使用了新的一网通框架，发现PC端无法访问内网的域名，导致某个功能无法正常运转，这个问题交到我手上，刚开始对这一方面实在是不熟悉，不知道从哪里入手，后来经过对计算机网络知识的了解，以及一些代码脚本的研读，发现是因为dnsmasq的配置出现了问题。 本文的目的接着上文一网通PC无法解析内网域名-dnsmasq，来解析如何进行动态更新dns上游服务器 dnsmasq简单介绍Dnsmasq 提供 DNS 缓存和 DHCP 服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。作为DHCP 服务器，dnsmasq 可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个 PXE 服务器, Dnsmasq配置文件是 /etc/dnsmasq.conf. linux init.rc启动脚本简单介绍这部分不在我们这边文章的范围内，有兴趣可以通过这篇文章作简单的了解-Android init.rc文件浅析 动态加载的流程获取到dns的更改通过Android源码的追踪，定位到在网络环境更改后，dns被重新写入的地方，在此处进行一个系统属性的建立12345678910111213141516171819202122232425262728293031323334private void updateDnses(LinkProperties newLp, LinkProperties oldLp, int netId, boolean flush, boolean useDefaultDns) &#123; if (oldLp == null || (newLp.isIdenticalDnses(oldLp) == false)) &#123; Collection&lt;InetAddress&gt; dnses = newLp.getDnsServers(); if (dnses.size() == 0 &amp;&amp; mDefaultDns != null &amp;&amp; useDefaultDns) &#123; dnses = new ArrayList(); dnses.add(mDefaultDns); if (DBG) &#123; loge("no dns provided for netId " + netId + ", so using defaults"); &#125; &#125; if (DBG) log("Setting Dns servers for network " + netId + " to " + dnses); try &#123; mNetd.setDnsServersForNetwork(netId, NetworkUtils.makeStrings(dnses), newLp.getDomains()); SystemProperties.set("sys.dns.change", "1"); // 设置我们自己创建的系统属性，用来出发脚本的service &#125; catch (Exception e) &#123; loge("Exception in setDnsServersForNetwork: " + e); &#125; NetworkAgentInfo defaultNai = mNetworkForRequestId.get(mDefaultRequest.requestId); if (defaultNai != null &amp;&amp; defaultNai.network.netId == netId) &#123; setDefaultDnsSystemProperties(dnses); &#125; flushVmDnsCache(); &#125; else if (flush) &#123; try &#123; mNetd.flushNetworkDnsCache(netId); &#125; catch (Exception e) &#123; loge("Exception in flushNetworkDnsCache: " + e); &#125; flushVmDnsCache(); &#125;&#125; 在设置了 sys.dns.change=1 后，会通过启动脚本中，on property的机制，出发另一个更新/data/misc/wifi/resolv.dnsmasq.conf上游dns服务器列表的动态更新，下面是启动脚本的主要内容123456789101112131415161718service dnsmasq_service /system/bin/dnsmasq -C /data/misc/wifi/dnsmasq.conf disabled class mainon property:sys.dns.needrst=1 restart dnsmasq_service setprop sys.dns.needrst 0on property:sys.dns.change=1 restart flush_service setprop sys.dns.change 0service flush_service /system/bin/flash_dns_nameserver.sh class main user root group root disabled oneshot 在这里，也遇到一个很纠结的问题，有兴趣可以读一下Linux init.rc Service Name 过长导致服务不可用的问题 进过一系列的属性设置，完成加载脚本以及重启dnsmasq服务下面是处理/data/misc/wifi/resolv.dnsmasq.conf的脚本flash_dns_nameserver.sh的内容：123456789101112131415161718192021#!/system/bin/shnet_dns=`/system/bin/getprop "net.dns1"`resolv_file="/data/misc/wifi/resolv.dnsmasq.conf"if [ -f $&#123;resolv_file&#125; ];then busybox rm $&#123;resolv_file&#125;fiif [ "$&#123;net_dns&#125;"x != ""x ];then echo "nameserver $net_dns" &gt;&gt; $&#123;resolv_file&#125; // 动态更新fiecho "nameserver 114.114.114.114" &gt;&gt; $&#123;resolv_file&#125;echo "nameserver 8.8.8.8" &gt;&gt; $&#123;resolv_file&#125; /system/bin/chmod 0666 $&#123;resolv_file&#125;/system/bin/chown system.wifi $&#123;resolv_file&#125;/system/bin/chmod 0777 /data/misc/wifi/system/bin/setprop sys.dns.change 0dnsmasq_serveice_state=`/system/bin/getprop "init.svc.dnsmasq_service"`if [ "$&#123;dnsmasq_serveice_state&#125;"x == "running"x ];then //需要重启dnsmasq来加载最新的dns配置 /system/bin/setprop sys.dns.needrst 1fi 到这里，dnsmasq的dns配置以及动态加载章节也就结束了，经过这个问题的处理，对开机流程，以及计算机网络的基础知识，dnsmasq都有了一定的认识，受益匪浅]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>一网通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一网通PC无法解析内网域名-Dnsmasq]]></title>
    <url>%2F2017%2F06%2F16%2Fpc-no-network-dnsmasq%2F</url>
    <content type="text"><![CDATA[问题由来前段时间，公司的一款产品，使用了新的一网通框架，发现PC端无法访问内网的域名，导致某个功能无法正常运转，这个问题交到我手上，刚开始对这一方面实在是不熟悉，不知道从哪里入手，后来经过对计算机网络知识的了解，以及一些代码脚本的研读，发现是因为dnsmasq的配置出现了问题。 dnsmasq简单介绍Dnsmasq 提供 DNS 缓存和 DHCP 服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。作为DHCP 服务器，dnsmasq 可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个 PXE 服务器, Dnsmasq配置文件是 /etc/dnsmasq.conf. 本文的目的从配置文件入手，解读dnsmasq配置文件中一般选项的作用和注意事项，此点为解决本问题的至关重要的原因 主要配置通用配置123456789101112131415161718192021#指定监听某个端口为dhcp、dns提供服务interface=eth1interface=wlan1#指定不监听except-interface=eth0# 服务监听的网络接口地址listen-address=192.168.8.132,127.0.0.1# 开启日志选项，记录在 /var/log/debug 中log-queries # 指定日志文件的路径，路径必须存在，否则会导致服务启动失败log-facility=/var/log/dnsmasq.log # 异步log，缓解阻塞。log-async=2#启动时不要进入后台，否则运行正常。 这是在dnsmasq在daemontools或launchd下运行时使用的。keep-in-foreground DNS配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546#这允许服务器在每个接口对应的/ etc / hosts中具有多个地址，主机将根据所连接的网络获取正确的地址localise-queries# 指定 DNS 服务的端口（默认53），设置为 0 表示关闭 DNS 服务，只使用 DHCP 服务port=53# 指定一个 hosts 文件，默认是从 /etc/hosts 中获取addn-hosts=/etc/other_hosts# 表示不使用 /etc/hosts 配置文件来解析域名no-hosts# 指定上游 DNS 服务列表的配置文件，默认是从 /etc/resolv.conf 中获取resolv-file=/data/misc/wifi/resolv.dnsmasq.conf#无论何时重新读取/etc/resolv.conf或通过DBus设置上游服务器，请清除DNS缓存。 当新的名称服务器可能具有与缓存中保存的数据不同的数据时，这很有用clear-on-reload# 表示严格按照上游 DNS 服务列表一个一个查询，否则将请求发送到所有 DNS 服务器，使用响应最快的服务器的结果strict-order# 不去读取/etc/resolv.conf。 仅从命令行或dnsmasq配置文件获取上游服务器no-resolv# 不允许 Dnsmasq 通过轮询 /etc/resolv.conf 或者其他文件来动态更新上游 DNS 服务列表no-poll# 表示对所有 server 发起查询请求，选择响应最快的服务器的结果all-servers# 指定 dnsmasq 默认查询的上游服务器server=8.8.8.8server=114.114.114.114# 指定 .cn 的域名全部通过 114.114.114.114 这台国内DNS服务器来解析server=/cn/114.114.114.114# 给 *.apple.com 和 taobao.com 使用专用的 DNSserver=/taobao.com/223.5.5.5server=/.apple.com/223.6.6.6# 增加一个域名，强制解析到所指定的地址上，dns 欺骗address=/taobao.com/127.0.0.1# 设置DNS缓存大小(单位：DNS解析条数)cache-size=500 DHCP配置12345678910111213141516171819202122232425262728#当dnsmasq绝对是网络上唯一的DHCP服务器时应该设置dhcp-authoritative# 指定分配的 IP 端和续约时间dhcp-range=192.168.1.50,192.168.1.100,12h# 同上，指定了子网掩码dhcp-range=192.168.8.50,192.168.8.150,255.255.255.0,12h# 指定网关地址dhcp-option=3,192.168.0.1# 指定 DNS 服务器，net:eth1 用来指定网卡dhcp-option=net:eth1,6,114.114.114.114，8.8.8.8dhcp-option=net:wlano,6,114.114.114.114，8.8.8.8# DHCP 所在的 domaindomain=gz.cvte.com# 静态地址绑定dhcp-host=00:0C:29:5E:F2:6F,192.168.1.201,os02dhcp-host=00:0C:29:15:63:CF,192.168.1.202,os03# 忽略一下 MAC 地址主机的请求dhcp-host=11:22:33:44:55:66,ignore# 租期保存文件dhcp-leasefile=/var/lib/dnsmasq/dnsmasq.leases 与问题相关以上分类介绍了与dnsmasq配置相关的一些选项，本问题出现的问题，主要原因就是在配置DNS服务器的时候，本来的措施是直接在dnsmasq.conf中写入固定的dns，并没有根据网络变化和状况去更新上游的dns服务器导致的，针对这个问题，我们在配置文件中进行了如下的更改1234#echo "no-resolv" &gt;&gt; "$dns_tfile"#echo "no-poll" &gt;&gt; "$dns_tfile"echo "resolv-file=/data/misc/wifi/resolv.dnsmasq.conf" &gt;&gt; "$dns_tfile"echo "clear-on-reload" &gt;&gt; "$dns_tfile" 这里的/data/misc/wifi/resolv.dnsmasq.conf即为dns上游服务器的枚举文件，格式如下12nameserver 114.114.114.114nameserver 8.8.8.8 这样就可以配置dns的上游服务器，使得动态的访问了。 后续dns上游服务器配置文件/data/misc/wifi/resolv.dnsmasq.conf的生成我们将在下一节一网通PC无法解析内网域名-dnsmasq–dns上游服务器的动态配置中解析]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>一网通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android wifiManager与wifiServices的消息传递机制]]></title>
    <url>%2F2017%2F06%2F14%2Fwifimanager-wifiservice-message%2F</url>
    <content type="text"><![CDATA[Android wifiManager与wifiServices的消息传递机制 背景在梳理Ap、wifi等部分的启动连接代码的时候，发现wifiManager和wifiService之间的消息传递使用了两套机制，两种机制都是用来进行不同进程之间的消息传递的，进过一些代码的阅读和查阅资料，发现两者有各自的优点和使用场景 主要内容通过代码认识 Messenger与AIDL 的特点和使用场景 AIDL 在两者之间的使用场景初始化在wifiManager.java中使用的IWifiManager对象是在WifiManager构造函数中从参数传递进来的1234567IWifiManager mService;public WifiManager(Context context, IWifiManager service) &#123; mContext = context; mService = service; init();&#125; 我们来看一下构造wifimanager的地方：123456789class ContextImpl extends Context &#123; registerService(WIFI_SERVICE, // 注册wifiservice new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(WIFI_SERVICE); IWifiManager service = IWifiManager.Stub.asInterface(b); // 创建一个 IWifiManager 实例化对象 return new WifiManager(ctx.getOuterContext(), service); // 实例化一个 WifiManager对象，调用了上面的构造函数 &#125;&#125;); &#125; 下面通过一个例子，介绍使用使用AIDL实现binder的例子用户打开wifi开关时，响应而下操作12345678910111213/*** Enable or disable Wi-Fi.* @param enabled &#123;@code true&#125; to enable, &#123;@code false&#125; to disable.* @return &#123;@code true&#125; if the operation succeeds (or if the existing state* is the same as the requested state).*/public boolean setWifiEnabled(boolean enabled) &#123; try &#123; return mService.setWifiEnabled(enabled); //调用 setWifiEnabled &#125; catch (RemoteException e) &#123; return false; &#125;&#125; 通过binder service，在wifiservice下的实现函数如下12345678910111213141516171819202122232425262728293031323334public final class WifiServiceImpl extends IWifiManager.Stub &#123; //通过AIDL进行编写 wifiservice中的函数基本都是实现wifimanager中的函数 /** * see &#123;@link android.net.wifi.WifiManager#setWifiEnabled(boolean)&#125; * @param enable &#123;@code true&#125; to enable, &#123;@code false&#125; to disable. * @return &#123;@code true&#125; if the enable/disable operation was * started or is already in the queue. */ public synchronized boolean setWifiEnabled(boolean enable) &#123; enforceChangePermission(); Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid()); if (DBG) &#123; Slog.e(TAG, "Invoking mWifiStateMachine.setWifiEnabled\n"); &#125; /* * Caller might not have WRITE_SECURE_SETTINGS, * only CHANGE_WIFI_STATE is enforced */ long ident = Binder.clearCallingIdentity(); try &#123; if (! mSettingsStore.handleWifiToggled(enable)) &#123; // Nothing to do if wifi cannot be toggled return true; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; mWifiController.sendMessage(CMD_WIFI_TOGGLED); return true; &#125; &#125; wifiservice的实例化在SystemServer.java中123private static final String WIFI_SERVICE_CLASS = "com.android.server.wifi.WifiService";mSystemServiceManager.startService(WIFI_SERVICE_CLASS); AIDL小结使用AIDL的时候，service端每收到一个client端的请求时，就会启动一个线程（非主线程）去执行相应的操作，即处理client端的请求是异步的。而且AIDL请求是，返回值是同步返回的。 Messenger 在两者之间的使用场景初始化下面是wifiManager的初始化函数init()123456789101112131415161718192021222324252627282930public WifiManager(Context context, IWifiManager service) &#123; mContext = context; mService = service; init();&#125;private void init() &#123; synchronized (sThreadRefLock) &#123; if (++sThreadRefCount == 1) &#123; Messenger messenger = getWifiServiceMessenger(); //此处通过AIDL获取 service端绑定的handle 这里借助了AIDL来获取client端的handle，因为此时还未建立异步通道，所以只能结束其他手段获取。 if (messenger == null) &#123; sAsyncChannel = null; return; &#125; sHandlerThread = new HandlerThread("WifiManager"); //创建一个handler线程，handler名位wifimanager sAsyncChannel = new AsyncChannel(); // 实例化一个异步通道 sConnected = new CountDownLatch(1); sHandlerThread.start(); //开启线程 Handler handler = new ServiceHandler(sHandlerThread.getLooper()); //创建client端的handle sAsyncChannel.connect(mContext, handler, messenger); //建立连接 try &#123; sConnected.await(); &#125; catch (InterruptedException e) &#123; Log.e(TAG, "interrupted wait at init"); &#125; &#125; &#125; &#125; 看一看wifiservice端的初始化1234567891011121314151617181920212223public WifiServiceImpl(Context context) &#123; mContext = context; mInterfaceName = SystemProperties.get("wifi.interface", "wlan0"); mTrafficPoller = new WifiTrafficPoller(mContext, mInterfaceName); mWifiStateMachine = new WifiStateMachine(mContext, mInterfaceName, mTrafficPoller); mWifiStateMachine.enableRssiPolling(true); mBatteryStats = BatteryStatsService.getService(); mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE); mNotificationController = new WifiNotificationController(mContext, mWifiStateMachine); mSettingsStore = new WifiSettingsStore(mContext); HandlerThread wifiThread = new HandlerThread("WifiService"); wifiThread.start(); mClientHandler = new ClientHandler(wifiThread.getLooper()); //创建一个接受client请求的handle ，请求处理在 ClientHandler 中 mWifiStateMachineHandler = new WifiStateMachineHandler(wifiThread.getLooper()); mWifiController = new WifiController(mContext, this, wifiThread.getLooper()); mBatchedScanSupported = mContext.getResources().getBoolean( R.bool.config_wifi_batched_scan_supported);&#125; 以下是在wifiServiceImpl.java中 getWifiServiceMessenger的实现1234567891011121314151617public Messenger getWifiServiceMessenger() &#123; enforceAccessPermission(); enforceChangePermission(); return new Messenger(mClientHandler);&#125;private class ClientHandler extends Handler &#123; //处理来自client请求的消息 ClientHandler(android.os.Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... &#125; &#125;&#125; 连接过程因为Messenger本质也是AIDL，只是进行了封装，所以我们展示封装以上的逻辑，具体的AIDL逻辑请参考Android：学习AIDL，这一篇文章就够了(上)有client端发起连接请求123456789101112131415161718192021222324private void init() &#123; synchronized (sThreadRefLock) &#123; if (++sThreadRefCount == 1) &#123; Messenger messenger = getWifiServiceMessenger(); if (messenger == null) &#123; sAsyncChannel = null; return; &#125; sHandlerThread = new HandlerThread("WifiManager"); sAsyncChannel = new AsyncChannel(); sConnected = new CountDownLatch(1); sHandlerThread.start(); Handler handler = new ServiceHandler(sHandlerThread.getLooper()); sAsyncChannel.connect(mContext, handler, messenger); // 发起连接 try &#123; sConnected.await(); &#125; catch (InterruptedException e) &#123; Log.e(TAG, "interrupted wait at init"); &#125; &#125; &#125; &#125; 进入connect 函数如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*** Connect handler and messenger.** Sends a CMD_CHANNEL_HALF_CONNECTED message to srcHandler when complete.* msg.arg1 = status* msg.obj = the AsyncChannel** @param srcContext* @param srcHandler* @param dstMessenger*/public void connect(Context srcContext, Handler srcHandler, Messenger dstMessenger) &#123; if (DBG) log("connect srcHandler to the dstMessenger E"); // We are connected connected(srcContext, srcHandler, dstMessenger); // 进行一些变量的赋值 // Tell source we are half connected replyHalfConnected(STATUS_SUCCESSFUL); // 回复给client消息处理的返回值(异步) if (DBG) log("connect srcHandler to the dstMessenger X");&#125; /** * Connect handler to messenger. This method is typically called* when a server receives a CMD_CHANNEL_FULL_CONNECTION request* and initializes the internal instance variables to allow communication* with the dstMessenger.** @param srcContext* @param srcHandler* @param dstMessenger*/public void connected(Context srcContext, Handler srcHandler, Messenger dstMessenger) &#123; if (DBG) log("connected srcHandler to the dstMessenger E"); // Initialize source fields mSrcContext = srcContext; mSrcHandler = srcHandler; mSrcMessenger = new Messenger(mSrcHandler); // Initialize destination fields mDstMessenger = dstMessenger; if (DBG) log("connected srcHandler to the dstMessenger X");&#125;/** * Reply to the src handler that we're half connected.* see: CMD_CHANNEL_HALF_CONNECTED for message contents** @param status to be stored in msg.arg1*/private void replyHalfConnected(int status) &#123; Message msg = mSrcHandler.obtainMessage(CMD_CHANNEL_HALF_CONNECTED); //发送消息 CMD_CHANNEL_HALF_CONNECTED 给 client端处理 msg.arg1 = status; msg.obj = this; msg.replyTo = mDstMessenger; /* * Link to death only when bindService isn't used. */ if (mConnection == null) &#123; mDeathMonitor = new DeathMonitor(); try &#123; mDstMessenger.getBinder().linkToDeath(mDeathMonitor, 0); &#125; catch (RemoteException e) &#123; mDeathMonitor = null; // Override status to indicate failure msg.arg1 = STATUS_BINDING_UNSUCCESSFUL; &#125; &#125; mSrcHandler.sendMessage(msg);&#125; 下面是wifimanager处理CMD_CHANNEL_HALF_CONNECTED的代码1234567891011case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) &#123; sAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION); // 发送消息 CMD_CHANNEL_FULL_CONNECTION 给 service端 &#125; else &#123; Log.e(TAG, "Failed to set up channel connection"); // This will cause all further async API calls on the WifiManager // to fail and throw an exception sAsyncChannel = null; &#125; sConnected.countDown(); break; 下面是wifiservice处理CMD_CHANNEL_FULL_CONNECTION的代码1234567891011121314151617case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION: &#123; AsyncChannel ac = new AsyncChannel(); ac.connect(mContext, this, msg.replyTo); // this 代表 clienthandle msg.replyTo代表信息发送方，即servicehandle break;&#125;case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: &#123; if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) &#123; if (DBG) Slog.d(TAG, "New client listening to asynchronous messages"); // We track the clients by the Messenger // since it is expected to be always available mTrafficPoller.addClient(msg.replyTo); &#125; else &#123; Slog.e(TAG, "Client connection failure, error=" + msg.arg1); &#125; break;&#125; connect函数的实现上面已经看过，这里即向ClientHandler发送CMD_CHANNEL_HALF_CONNECTED消息，参数是STATUS_SUCCESSFUL,执行mTrafficPoller.addClient(msg.replyTo);将WifiMananger的ServiceHandler加入到Wifi系统的流量轮询管理机制当中，用于以后通知ServiceHandler不同的状态。到此，WifiManager和WifiService之间的一个基于AsyncChannel的双向通信连接就建立完成 举例123456789101112131415161718192021222324/** * Connect to a network with the given configuration. The network also * gets added to the supplicant configuration. * * For a new network, this function is used instead of a * sequence of addNetwork(), enableNetwork(), saveConfiguration() and * reconnect() * * @param config the set of variables that describe the configuration, * contained in a &#123;@link WifiConfiguration&#125; object. * @param listener for callbacks on success or failure. Can be null. * @throws IllegalStateException if the WifiManager instance needs to be * initialized again * * @hide */public void connect(WifiConfiguration config, ActionListener listener) &#123; if (config == null) throw new IllegalArgumentException("config cannot be null"); validateChannel(); // Use INVALID_NETWORK_ID for arg1 when passing a config object // arg1 is used to pass network id when the network already exists sAsyncChannel.sendMessage(CONNECT_NETWORK, WifiConfiguration.INVALID_NETWORK_ID, putListener(listener), config); // 发送信息给 service端进行处理&#125; 消息填入队列后等待service端pull然后handle即可 两者的主要区别和不同总结 Messenger本质也是AIDL，只是进行了封装，开发的时候不用再写.aidl文件。 因为不用去写.aidl文件，相比起来，Messenger使用起来十分简单。但前面也说了，Messenger本质上也是AIDL，故在底层进程间通信这一块，两者的效率应该是一样的。 在service端，Messenger处理client端的请求是同步的，而AIDL是异步的。 使用AIDL的时候，service端每收到一个client端的请求时，就会启动一个线程（非主线程）去执行相应的操作。而Messenger，service收到的请求是放在Handler的messageQueue里面，Handler大家都用过，它需要绑定一个Thread，然后不断poll message执行相关操作，这个过程是同步执行的。 client的方法，使用AIDL获取返回值是同步的，而Messenger是异步的。 Messenger只提供了一个方法进行进程间通信，就是send(Message msg)方法，发送的是一个Message，没有返回值，要拿到返回值，需要把client的Messenger作为msg.replyTo参数传递过去，service端处理完之后，在调用客户端的Messenger的send(Message msg)方法把返回值传递回client，这个过程是异步的，而AIDL你可以自己指定方法，指定返回值，它获取返回值是同步的。 其实，第二点是有办法解决的，在service端，Messenger的Handler可以只当作一个转发器，不处理请求，只转发请求到相应的处理线程（多是相应的HandlerThread），这样也可以达到异步的效果。]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>Android wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Wifi 启动流程详细分析]]></title>
    <url>%2F2017%2F06%2F12%2FAndroid-wifi-start%2F</url>
    <content type="text"><![CDATA[Android wifi 启动流程详细分析Android 版本 Android 5.1 目的 了解Android wifi 启动过程中的消息传递，状态机切换，以及必要的操作等 具体流程当我在Setting菜单里点击打开Wifi时，调用的入口函数是WifiManager::setWifiEnabled(boolean enabled)：12345678910111213/** * Enable or disable Wi-Fi. * @param enabled &#123;@code true&#125; to enable, &#123;@code false&#125; to disable. * @return &#123;@code true&#125; if the operation succeeds (or if the existing state * is the same as the requested state). */ public boolean setWifiEnabled(boolean enabled) &#123; try &#123; return mService.setWifiEnabled(enabled); // wifimanager setwifienabled -&gt;(AIDL) wifiservice setwifienabled &#125; catch (RemoteException e) &#123; return false; &#125; &#125; 通过AIDL方式，实际调用的是 WifiServiceImpl::setWifiEnabled(boolean enable)：1234567891011121314151617181920212223242526272829303132/** * see &#123;@link android.net.wifi.WifiManager#setWifiEnabled(boolean)&#125; * @param enable &#123;@code true&#125; to enable, &#123;@code false&#125; to disable. * @return &#123;@code true&#125; if the enable/disable operation was * started or is already in the queue. */ public synchronized boolean setWifiEnabled(boolean enable) &#123; enforceChangePermission(); Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid()); if (DBG) &#123; Slog.e(TAG, "Invoking mWifiStateMachine.setWifiEnabled\n"); &#125; /* * Caller might not have WRITE_SECURE_SETTINGS, * only CHANGE_WIFI_STATE is enforced */ long ident = Binder.clearCallingIdentity(); try &#123; if (! mSettingsStore.handleWifiToggled(enable)) &#123; // Nothing to do if wifi cannot be toggled return true; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; mWifiController.sendMessage(CMD_WIFI_TOGGLED);// 发送消息 CMD_WIFI_TOGGLED 给 wificontroller 状态机 return true; &#125; 从代码可以看出，这里主要的操作是将wifi是否enable的状态存入数据库、向WiFiController发送了CMD_WIFI_TOGGLED消息。WifiController实际上是一个状态机，相比WifiStateMachine，它的状态较少，结构也比较简单。WifiController的定义及构造函数：12345678910111213141516171819202122232425262728293031323334353637class WifiController extends StateMachine &#123; ... WifiController(Context context, WifiServiceImpl service, Looper looper) &#123; super(TAG, looper); ... //树状结构，代表相应的父子关系 addState(mDefaultState); addState(mApStaDisabledState, mDefaultState); addState(mStaEnabledState, mDefaultState); addState(mDeviceActiveState, mStaEnabledState); addState(mDeviceInactiveState, mStaEnabledState); addState(mScanOnlyLockHeldState, mDeviceInactiveState); addState(mFullLockHeldState, mDeviceInactiveState); addState(mFullHighPerfLockHeldState, mDeviceInactiveState); addState(mNoLockHeldState, mDeviceInactiveState); addState(mStaDisabledWithScanState, mDefaultState); addState(mApEnabledState, mDefaultState); addState(mEcmState, mDefaultState); boolean isAirplaneModeOn = mSettingsStore.isAirplaneModeOn(); boolean isWifiEnabled = mSettingsStore.isWifiToggleEnabled(); boolean isScanningAlwaysAvailable = mSettingsStore.isScanAlwaysAvailable(); log("isAirplaneModeOn = " + isAirplaneModeOn + ", isWifiEnabled = " + isWifiEnabled + ", isScanningAvailable = " + isScanningAlwaysAvailable); if (isScanningAlwaysAvailable) &#123; setInitialState(mStaDisabledWithScanState); &#125; else &#123; setInitialState(mApStaDisabledState); // 通常是从这里开始 &#125; ... &#125; ... &#125; WifiController状态机的创建、开启工作在WifiServiceImpl中完成：123456789101112131415161718192021public WifiServiceImpl(Context context) &#123; mContext = context; mInterfaceName = SystemProperties.get("wifi.interface", "wlan0");// 默认 wlan0 mTrafficPoller = new WifiTrafficPoller(mContext, mInterfaceName); mWifiStateMachine = new WifiStateMachine(mContext, mInterfaceName, mTrafficPoller); // wifistatemachine 实例化 mWifiStateMachine.enableRssiPolling(true); mBatteryStats = BatteryStatsService.getService(); mPowerManager = context.getSystemService(PowerManager.class); mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE); mUserManager = UserManager.get(mContext); mNotificationController = new WifiNotificationController(mContext, mWifiStateMachine); mSettingsStore = new WifiSettingsStore(mContext); HandlerThread wifiThread = new HandlerThread("WifiService"); wifiThread.start(); mClientHandler = new ClientHandler(wifiThread.getLooper()); // async 在 wifimanager 和 wifiserviceimpl mWifiStateMachineHandler = new WifiStateMachineHandler(wifiThread.getLooper()); mWifiController = new WifiController(mContext, this, wifiThread.getLooper()); // mWifiController 实例化 WifiControlle状态机的初始状态由一些配置信息决定。当ApStaDisabledState为初始状态时，看对CMD_WIFI_TOGGLED消息的处理：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ApStaDisabledState extends State &#123; ... @Override public boolean processMessage(Message msg) &#123; switch (msg.what) &#123; case CMD_WIFI_TOGGLED: case CMD_AIRPLANE_TOGGLED: if (mSettingsStore.isWifiToggleEnabled()) &#123; if (doDeferEnable(msg)) &#123; if (mHaveDeferredEnable) &#123; // have 2 toggles now, inc serial number an ignore both mDeferredEnableSerialNumber++; &#125; mHaveDeferredEnable = !mHaveDeferredEnable; break; &#125; if (mDeviceIdle == false) &#123; transitionTo(mDeviceActiveState); // 切换到状态 mDeviceActiveState &#125; else &#123; checkLocksAndTransitionWhenDeviceIdle(); &#125; &#125; else if (mSettingsStore.isScanAlwaysAvailable()) &#123; transitionTo(mStaDisabledWithScanState); &#125; break; case CMD_SCAN_ALWAYS_MODE_CHANGED: if (mSettingsStore.isScanAlwaysAvailable()) &#123; transitionTo(mStaDisabledWithScanState); &#125; break; ... default: return NOT_HANDLED; &#125; return HANDLED; &#125; private boolean doDeferEnable(Message msg) &#123; long delaySoFar = SystemClock.elapsedRealtime() - mDisabledTimestamp; if (delaySoFar &gt;= mReEnableDelayMillis) &#123; return false; &#125; log("WifiController msg " + msg + " deferred for " + (mReEnableDelayMillis - delaySoFar) + "ms"); // need to defer this action. Message deferredMsg = obtainMessage(CMD_DEFERRED_TOGGLE); deferredMsg.obj = Message.obtain(msg); deferredMsg.arg1 = ++mDeferredEnableSerialNumber; sendMessageDelayed(deferredMsg, mReEnableDelayMillis - delaySoFar + DEFER_MARGIN_MS); return true; &#125; 接着转换到DeviceActiveState状态。StaEnabledState是它的父状态，由StateMachine的知识可知，转换到该状态时，会依次调用父、子状态的enter()函数。我们看两个状态的enter()函数：12345678910111213141516171819class StaEnabledState extends State &#123; @Override public void enter() &#123; mWifiStateMachine.setSupplicantRunning(true); //启动 wps_supplicant &#125; ... &#125; &#125; /* Parent: StaEnabledState */ class DeviceActiveState extends State &#123; @Override public void enter() &#123; mWifiStateMachine.setOperationalMode(WifiStateMachine.CONNECT_MODE); //设置wifi操作模式 mWifiStateMachine.setDriverStart(true); //启动驱动 mWifiStateMachine.setHighPerfModeEnabled(false);//此处分析忽略，关系不大 &#125; ... &#125; 这里依次会向WifiStateMachine发送三个消息，最后一个消息这里忽略： WifiStateMachine.setSupplicantRunning(true)：发送CMD_START_SUPPLICANT消息 WifiStateMachine.setOperationalMode(WifiStateMachine.CONNECT_MODE)：发送CMD_SET_OPERATIONAL_MODE消息，参数是CONNECT_MODE WifiStateMachine.setDriverStart(true)：发送CMD_START_DRIVER消息 在此之前，我们先看下第二点中的参数CONNECT_MODE的含义。在WifiStateMachine中，已经有了如下定义：1234567891011121314/* Wifi state machine modes of operation */ /* CONNECT_MODE - connect to any 'known' AP when it becomes available */ public static final int CONNECT_MODE = 1; /* SCAN_ONLY_MODE - don't connect to any APs; scan, but only while apps hold lock */ public static final int SCAN_ONLY_MODE = 2; /* SCAN_ONLY_WITH_WIFI_OFF - scan, but don't connect to any APs */ public static final int SCAN_ONLY_WITH_WIFI_OFF_MODE = 3; /* 3 operational states for STA operation: CONNECT_MODE, SCAN_ONLY_MODE, SCAN_ONLY_WIFI_OFF_MODE * In CONNECT_MODE, the STA can scan and connect to an access point * In SCAN_ONLY_MODE, the STA can only scan for access points * In SCAN_ONLY_WIFI_OFF_MODE, the STA can only scan for access points with wifi toggle being off */ private int mOperationalMode = CONNECT_MODE; 可知Wifi状态机一共有三种处理模式： CONNECT_MODE：该状态下Wifi可以扫描AP，也可以连接AP SCAN_ONLY_MODE：该状态下Wifi仅可以扫描AP SCAN_ONLY_WIFI_OFF_MODE：该状态下，Wifi仅可以当Wifi toogle off时允许扫描AP 现在，我们将处理的过程转换到WifiStateMachine。WifiStateMachine是一个复杂的状态机，它维护了Wifi的启动、扫描、连接、断开等多个状态。它运行在自己独有的线程中，拥有自己的消息队列 分别来看WifiStateMachine是怎么处理这三个消息的。InitialState首先接收到CMD_START_SUPPLICANT消息并处理：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case CMD_START_SUPPLICANT: if (mWifiNative.loadDriver()) &#123;//加载 rtl8821au 驱动 try &#123; mNwService.wifiFirmwareReload(mInterfaceName, "STA");//以STA模式 加载 wlan固件(command: soft fwreload) &#125; catch (Exception e) &#123; loge("Failed to reload STA firmware " + e); // Continue &#125; try &#123; // A runtime crash can leave the interface up and // IP addresses configured, and this affects // connectivity when supplicant starts up. // Ensure interface is down and we have no IP // addresses before a supplicant start. mNwService.setInterfaceDown(mInterfaceName); // (command: Inferface getcfg or setcfg) mNwService.clearInterfaceAddresses(mInterfaceName); // (command: Inferface clearaddrs) // Set privacy extensions mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true); // IPv6 is enabled only as long as access point is connected since: // - IPv6 addresses and routes stick around after disconnection // - kernel is unaware when connected and fails to start IPv6 negotiation // - kernel can start autoconfiguration when 802.1x is not complete mNwService.disableIpv6(mInterfaceName); &#125; catch (RemoteException re) &#123; loge("Unable to change interface settings: " + re); &#125; catch (IllegalStateException ie) &#123; loge("Unable to change interface settings: " + ie); &#125; /* Stop a running supplicant after a runtime restart * Avoids issues with drivers that do not handle interface down * on a running supplicant properly. */ mWifiMonitor.killSupplicant(mP2pSupported); if (mWifiNative.startSupplicant(mP2pSupported)) &#123;//启动wpa_s setWifiState(WIFI_STATE_ENABLING); if (DBG) log("Supplicant start successful"); mWifiMonitor.startMonitoring();//建立与wpa_s之间的socket通信连接；开启线程，循环接收来自wpa_s的event，并分发处理 transitionTo(mSupplicantStartingState); &#125; else &#123; loge("Failed to start supplicant!"); &#125; &#125; else &#123; loge("Failed to load driver"); &#125; break; 主要的处理过程包括： WifiNative.loadDriver()：加载Wifi驱动，实际的实现是在wifi.c中 NetworkManagementService.wifiFirmwareReload(mInterfaceName, “STA”)：加载wlan固件 WifiNative.startSupplicant(mP2pSupported)：启动wpa_supplicant WifiMonitor.startMonitoring()：这一步主要是在WifiMonitor中建立与wpa_supplicant通信的socket通道、创建一个线程接收底层事件并分发处理。这里会创建两个socket通道与wpa_s通信，一个用于下发指令，另一个用于接收事件。成功后WifiMonitor会向WifiStateMachine发送一个代表socket通信建立成功的消息：SUP_CONNECTION_EVENT；收到这个消息就表示Wifi已经启动成功了。 切换到SupplicantStartingState。 进入SupplicantStartingState后，第一个消息就处理完毕，这时消息队列中按处理先后顺序仍有三个消息： CMD_SET_OPERATIONAL_MODE，参数是CONNECT_MODE CMD_START_DRIVER SUP_CONNECTION_EVENT 切换到SupplicantStartingState，消息队列中的前两个消息在该状态会被延迟处理，直接看SUP_CONNECTION_EVENT的处理过程：12345678910111213141516171819202122232425case WifiMonitor.SUP_CONNECTION_EVENT: if (DBG) log("Supplicant connection established"); setWifiState(WIFI_STATE_ENABLED); mSupplicantRestartCount = 0; /* Reset the supplicant state to indicate the supplicant * state is not known at this time */ mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE); /* Initialize data structures */ mLastBssid = null; mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID; mLastSignalLevel = -1; mWifiInfo.setMacAddress(mWifiNative.getMacAddress()); /* set frequency band of operation */ setFrequencyBand(); mWifiNative.enableSaveConfig(); mWifiConfigStore.loadAndEnableAllNetworks();//加载并enable保存的AP if (mWifiConfigStore.enableVerboseLogging.get() &gt; 0) &#123; enableVerboseLogging(mWifiConfigStore.enableVerboseLogging.get()); &#125; initializeWpsDetails(); sendSupplicantConnectionChangedBroadcast(true);//广播通知Wpa_s连接已建立，此时已经可以准备连接或扫描Wifi了 transitionTo(mDriverStartedState); break; 这里主要是调用WifiConfigStore.loadAndEnableAllNetworks()加载并enable所有保存在wpa_s中的AP，然后做一些其他的初始化工作，切换到DriverStartedState状态。关注其父状态和自身的enter()函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122class SupplicantStartedState extends State &#123; @Override public void enter() &#123; /* Wifi is available as long as we have a connection to supplicant */ mNetworkInfo.setIsAvailable(true); if (mNetworkAgent != null) mNetworkAgent.sendNetworkInfo(mNetworkInfo); int defaultInterval = mContext.getResources().getInteger( R.integer.config_wifi_supplicant_scan_interval); mSupplicantScanIntervalMs = Settings.Global.getLong(mContext.getContentResolver(), Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval); mWifiNative.setScanInterval((int)mSupplicantScanIntervalMs / 1000);//设置扫描时间间隔 mWifiNative.setExternalSim(true); /* turn on use of DFS channels */ WifiNative.setDfsFlag(true); /* set country code */ setCountryCode(); setRandomMacOui(); mWifiNative.enableAutoConnect(false); //可以事先注意该设置 &#125; &#125; class DriverStartedState extends State &#123; @Override public void enter() &#123; if (PDBG) &#123; logd("DriverStartedState enter"); &#125; mWifiLogger.startLogging(mVerboseLoggingLevel &gt; 0); mIsRunning = true; mInDelayedStop = false; mDelayedStopCounter++; updateBatteryWorkSource(null); /** * Enable bluetooth coexistence scan mode when bluetooth connection is active. * When this mode is on, some of the low-level scan parameters used by the * driver are changed to reduce interference with bluetooth */ mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive); /* initialize network state */ setNetworkDetailedState(DetailedState.DISCONNECTED); /* Remove any filtering on Multicast v6 at start */ mWifiNative.stopFilteringMulticastV6Packets(); /* Reset Multicast v4 filtering state */ if (mFilteringMulticastV4Packets.get()) &#123; mWifiNative.startFilteringMulticastV4Packets(); &#125; else &#123; mWifiNative.stopFilteringMulticastV4Packets(); &#125; mDhcpActive = false; if (mOperationalMode != CONNECT_MODE) &#123; mWifiNative.disconnect(); mWifiConfigStore.disableAllNetworks(); if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) &#123; setWifiState(WIFI_STATE_DISABLED); &#125; transitionTo(mScanModeState); &#125; else &#123; // Status pulls in the current supplicant state and network connection state // events over the monitor connection. This helps framework sync up with // current supplicant state // TODO: actually check th supplicant status string and make sure the supplicant // is in disconnecte4d state. mWifiNative.status(); // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin transitionTo(mDisconnectedState); &#125; // We may have missed screen update at boot if (mScreenBroadcastReceived.get() == false) &#123; PowerManager powerManager = (PowerManager)mContext.getSystemService( Context.POWER_SERVICE); handleScreenStateChanged(powerManager.isScreenOn()); &#125; else &#123; // Set the right suspend mode settings mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 &amp;&amp; mUserWantsSuspendOpt.get()); &#125; mWifiNative.setPowerSave(true); if (mP2pSupported) &#123; if (mOperationalMode == CONNECT_MODE) &#123; mWifiP2pChannel.sendMessage(WifiStateMachine.CMD_ENABLE_P2P);//支持p2p，则会发送命令enbale p2p &#125; else &#123; // P2P statemachine starts in disabled state, and is not enabled until // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to // keep it disabled. &#125; &#125; final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED); mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL); mHalFeatureSet = WifiNative.getSupportedFeatureSet(); if ((mHalFeatureSet &amp; WifiManager.WIFI_FEATURE_HAL_EPNO) == WifiManager.WIFI_FEATURE_HAL_EPNO) &#123; mHalBasedPnoDriverSupported = true; &#125; // Enable link layer stats gathering mWifiNative.setWifiLinkLayerStats("wlan0", 1); if (PDBG) &#123; logd("Driverstarted State enter done, epno=" + mHalBasedPnoDriverSupported + " feature=" + mHalFeatureSet); &#125; &#125; &#125; SupplicantStartedState的enter()函数设置了Wifi扫描间隔；DriverStartedState的enter()函数主要进行了一些相关的设置工作，根据配置启动p2p。最后在enter()函数中会将状态切换到DisconnectedState。消息队列中被延迟的两条消息此时会被处理： CMD_SET_OPERATIONAL_MODE消息在DisconnectedState被处理，将mOperationalMode设置为CONNECT_MODE；Wifi状态机中该字段的默认值也是该值。 CMD_START_DRIVER消息则在DriverStartedState中被处理。 最后转换到DisconnectedState状态，关注enter()函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void enter() &#123; // We dont scan frequently if this is a temporary disconnect // due to p2p if (mTemporarilyDisconnectWifi) &#123; mWifiP2pChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE); return; &#125; if (PDBG) &#123; logd(" Enter DisconnectedState scan interval " + mWifiConfigStore.wifiDisconnectedShortScanIntervalMilli.get() + " mLegacyPnoEnabled= " + mLegacyPnoEnabled + " screenOn=" + mScreenOn + " useGscan=" + mHalBasedPnoDriverSupported + "/" + mWifiConfigStore.enableHalBasedPno.get()); &#125; /** clear the roaming state, if we were roaming, we failed */ mAutoRoaming = WifiAutoJoinController.AUTO_JOIN_IDLE; if (useHalBasedAutoJoinOffload()) &#123; startGScanDisconnectedModeOffload("disconnectedEnter"); &#125; else &#123; if (mScreenOn) &#123; /** * screen lit and =&gt; delayed timer */ startDelayedScan(500, null, null); &#125; else &#123; /** * screen dark and PNO supported =&gt; scan alarm disabled */ if (mBackgroundScanSupported) &#123; /* If a regular scan result is pending, do not initiate background * scan until the scan results are returned. This is needed because * initiating a background scan will cancel the regular scan and * scan results will not be returned until background scanning is * cleared */ if (!mIsScanOngoing) &#123; enableBackgroundScan(true);//启动wifi扫描，随后会触发autojoin，进行连接操作 &#125; &#125; else &#123; setScanAlarm(true);//启动一个扫描定时器 &#125; &#125; &#125; /** * If we have no networks saved, the supplicant stops doing the periodic scan. * The scans are useful to notify the user of the presence of an open network. * Note that these are not wake up scans. */ if (mNoNetworksPeriodicScan != 0 &amp;&amp; !mP2pConnected.get() &amp;&amp; mWifiConfigStore.getConfiguredNetworks().size() == 0) &#123; sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan); &#125; mDisconnectedTimeStamp = System.currentTimeMillis(); mDisconnectedPnoAlarmCount = 0; &#125; 在enter()函数中，会进行scan动作；WifiStateMachine处理SCAN_RESULTS_EVENT消息时，就会进入autojoin流程，尝试AP重连]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>Android wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[510 原生AP启动流程解析]]></title>
    <url>%2F2017%2F06%2F07%2FAndroid-softap-start%2F</url>
    <content type="text"><![CDATA[510 原生AP启动流程解析 一. 原生AP打开流程 当我们在Setting菜单中打卡原生AP的开关后，会执行如下代码1234567891011121314//Android/packages/apps/Settings/src/com/android/settings/TetherSettings.javapublic boolean onPreferenceChange(Preference preference, Object value) &#123; boolean enable = (Boolean) value; if (enable) &#123; //想要打开 startProvisioningIfNecessary(WIFI_TETHERING); //WIFI_TETHERING 通过wifi进行热点的分享 &#125; else &#123; //想要关闭 if (isProvisioningNeeded(mProvisionApp)) &#123; TetherService.cancelRecheckAlarmIfNecessary(getActivity(), WIFI_TETHERING); &#125; mWifiApEnabler.setSoftapEnabled(false); &#125; return false;&#125; isProvisioningNeeded 用来检测是否需要进行一些准备工作，enable 为上层传下来的打开关闭标志位，当想要打开时，会执行 startProvisioningIfNecessary123456789101112//Android/packages/apps/Settings/src/com/android/settings/TetherSettings.java private void startProvisioningIfNecessary(int choice) &#123; mTetherChoice = choice; if (isProvisioningNeeded(mProvisionApp)) &#123; Intent intent = new Intent(Intent.ACTION_MAIN); intent.setClassName(mProvisionApp[0], mProvisionApp[1]); intent.putExtra(TETHER_CHOICE, mTetherChoice); startActivityForResult(intent, PROVISION_REQUEST); &#125; else &#123; startTethering(); //已准备就绪 &#125; &#125; 正常流程会执行 startTethering1234567891011121314151617//Android/packages/apps/Settings/src/com/android/settings/TetherSettings.java private void startTethering() &#123; switch (mTetherChoice) &#123; case WIFI_TETHERING: mWifiApEnabler.setSoftapEnabled(true); break; case BLUETOOTH_TETHERING: ... break; case USB_TETHERING: ... break; default: //should not happen break; &#125; &#125; 执行 WifiApEnabler.setSoftapEnabled(true)12345678910111213141516171819202122232425262728293031323334353637383940//Android/packages/apps/Settings/src/com/android/settings/wifi/WifiApEnabler.java public void setSoftapEnabled(boolean enable) &#123; final ContentResolver cr = mContext.getContentResolver(); /** * Disable Wifi if enabling tethering */ int wifiState = mWifiManager.getWifiState();//获取wifi状态 if (enable &amp;&amp; ((wifiState == WifiManager.WIFI_STATE_ENABLING) || (wifiState == WifiManager.WIFI_STATE_ENABLED))) &#123; mWifiManager.setWifiEnabled(false);// 关闭WIFI Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 1);// 记录WIIF状态 &#125; if (mWifiManager.setWifiApEnabled(null, enable)) &#123; if (mSwitch != null) &#123; /* Disable here, enabled on receiving success broadcast */ mSwitch.setEnabled(false); &#125; &#125; else &#123; if (mSwitch != null) &#123; mSwitch.setSummary(R.string.wifi_error); &#125; &#125; /** * If needed, restore Wifi on tether disable */ if (!enable) &#123; int wifiSavedState = 0; try &#123; wifiSavedState = Settings.Global.getInt(cr, Settings.Global.WIFI_SAVED_STATE);//获取保存的wifi状态 &#125; catch (Settings.SettingNotFoundException e) &#123; ; &#125; if (wifiSavedState == 1) &#123; mWifiManager.setWifiEnabled(true); //恢复wifi为开启的状态 Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 0);//修改状态 &#125; &#125; &#125; google在此处考虑的很周到，当需要打开softAP并且wifi处于打开状态时，会关闭wifi并且保存wifi曾经为打开状态，当关闭时重新打开wifi的开关，打开softAp的代码是WifiManager.setWifiApEnabled(null, enable)123456789//Android/frameworks/base/wifi/java/android/net/wifi/WifiManager.java public boolean setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) &#123; try &#123; mService.setWifiApEnabled(wifiConfig, enabled); return true; &#125; catch (RemoteException e) &#123; return false; &#125; &#125; 进入到framework层的wifimanager123456789101112131415//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.javapublic void setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) &#123; enforceChangePermission(); ConnectivityManager.enforceTetherChangePermission(mContext); UserManager um = UserManager.get(mContext); if (um.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) &#123; throw new SecurityException("DISALLOW_CONFIG_TETHERING is enabled for this user."); &#125; // null wifiConfig is a meaningful input for CMD_SET_AP if (wifiConfig == null || wifiConfig.isValid()) &#123; //wifiConfig可以是空 mWifiController.obtainMessage(CMD_SET_AP, enabled ? 1 : 0, 0, wifiConfig).sendToTarget();//发送CMD_SET_AP的消息给 WifiController &#125; else &#123; Slog.e(TAG, "Invalid WifiConfiguration"); &#125; &#125; 给wificontroller发送一个CMD_SET_AP的消息，下面会进入wificontroller1class WifiController extends StateMachine 其本身也是一个状态机，看一下他的构造函数：1234567891011121314151617181920212223242526272829303132333435//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.java WifiController(Context context, WifiServiceImpl service, Looper looper) &#123; super(TAG, looper); mContext = context; mWifiStateMachine = service.mWifiStateMachine; mSettingsStore = service.mSettingsStore; mLocks = service.mLocks; mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE); Intent idleIntent = new Intent(ACTION_DEVICE_IDLE, null); mIdleIntent = PendingIntent.getBroadcast(mContext, IDLE_REQUEST, idleIntent, 0); addState(mDefaultState); addState(mApStaDisabledState, mDefaultState); addState(mStaEnabledState, mDefaultState); addState(mDeviceActiveState, mStaEnabledState); addState(mDeviceInactiveState, mStaEnabledState); addState(mScanOnlyLockHeldState, mDeviceInactiveState); addState(mFullLockHeldState, mDeviceInactiveState); addState(mFullHighPerfLockHeldState, mDeviceInactiveState); addState(mNoLockHeldState, mDeviceInactiveState); addState(mStaDisabledWithScanState, mDefaultState); addState(mApEnabledState, mDefaultState); addState(mEcmState, mDefaultState); boolean isAirplaneModeOn = mSettingsStore.isAirplaneModeOn(); boolean isWifiEnabled = mSettingsStore.isWifiToggleEnabled(); boolean isScanningAlwaysAvailable = mSettingsStore.isScanAlwaysAvailable(); if (isScanningAlwaysAvailable) &#123; setInitialState(mStaDisabledWithScanState); &#125; else &#123; setInitialState(mApStaDisabledState); //设置初始状态 &#125; ｝ 初始状态一般为 mApStaDisabledState，发送的了消息CMD_SET_AP进入 mApStaDisabledState 的 processmessage中123456789101112//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.javaclass ApStaDisabledState extends State &#123; public boolean processMessage(Message msg) &#123; case CMD_SET_AP: if (msg.arg1 == 1) &#123; //enable mWifiStateMachine.setHostApRunning((WifiConfiguration) msg.obj, true);//从msg中拿出wificonfig（为空） transitionTo(mApEnabledState);// WifiController状态机的状态切换到mApEnabledState &#125; break; &#125;&#125; 此时会调用 setHostApRunning 函数并将wificontroller状态设置为 mApEnabledState12345678//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java public void setHostApRunning(WifiConfiguration wifiConfig, boolean enable) &#123; if (enable) &#123; sendMessage(CMD_START_AP, wifiConfig);//wifiConfig为空 &#125; else &#123; sendMessage(CMD_STOP_AP); &#125; &#125; 发送消息CMD_START_AP到WifiStateMachine wifistateMchine是处理wifi所有事物的核心状态机 我们来看一下它的构造函数：12//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javasetInitialState(mInitialState); 初始状态为mInitialState(其实mInitialState的父状态为mDefaultState)，执行前会先执行mDefaultState 我们看一下初始状态mInitialState的enter函数12345678910111213141516171819//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javapublic void enter() &#123; mWifiNative.unloadDriver(mWifiMode); if (mWifiP2pChannel == null) &#123; mWifiP2pChannel = new AsyncChannel(); mWifiP2pChannel.connect(mContext, getHandler(), mWifiP2pServiceImpl.getP2pStateMachineMessenger()); &#125; if (mWifiApConfigChannel == null) &#123; mWifiApConfigChannel = new AsyncChannel(); WifiApConfigStore wifiApConfigStore = WifiApConfigStore.makeWifiApConfigStore( mContext, getHandler()); wifiApConfigStore.loadApConfiguration();//加载默认的softap.conf到配置变量 mWifiApConfig mWifiApConfigChannel.connectSync(mContext, getHandler(), wifiApConfigStore.getMessenger()); &#125;&#125; 这里会构造一个wifiApConfigStore的实例，然后通过wifiApConfigStore.loadApConfiguration()加载Ap的configuration信息12345678910111213141516171819202122232425262728293031323334//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiApConfigStore.javaprivate static final String AP_CONFIG_FILE = Environment.getDataDirectory() + "/misc/wifi/softap.conf"; void loadApConfiguration() &#123; DataInputStream in = null; try &#123; WifiConfiguration config = new WifiConfiguration(); in = new DataInputStream(new BufferedInputStream(new FileInputStream( AP_CONFIG_FILE))); int version = in.readInt(); if (version != 1) &#123; Log.e(TAG, "Bad version on hotspot configuration file, set defaults"); setDefaultApConfiguration(); return; &#125; config.SSID = in.readUTF(); int authType = in.readInt(); config.allowedKeyManagement.set(authType); if (authType != KeyMgmt.NONE) &#123; config.preSharedKey = in.readUTF(); &#125; mWifiApConfig = config; &#125; catch (IOException ignore) &#123; setDefaultApConfiguration(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123;&#125; &#125; &#125; &#125; 读取/data/misc/wifi/softap.conf的配置并且写入mWifiApConfig 接上上面的消息CMD_START_AP，在mInitialState进行处理1234567891011121314//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javaclass InitialState extends State &#123; public boolean processMessage(Message msg) &#123; case CMD_START_AP: mWifiMode = 1; if (mWifiNative.loadDriver(mWifiMode)) &#123; setWifiApState(WIFI_AP_STATE_ENABLING); transitionTo(mSoftApStartingState); &#125; else &#123; loge("Failed to load driver for softap"); setWifiApState(WIFI_AP_STATE_FAILED); &#125; &#125;&#125; 首先需要先loadDriver，它是一个native函数，JNI函数如下12345//frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cppstatic jboolean android_net_wifi_loadDriver(JNIEnv* env, jobject, jint mode)&#123; return (::wifi_load_driver(mode) == 0);&#125; 进入wifi_load_driver函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//Android/hardware/libhardware_legacy/wifi/wifi.cint wifi_load_driver(int mode)&#123;#ifdef WIFI_DRIVER_MODULE_PATH char driver_status[PROPERTY_VALUE_MAX]; int count = 100; /* wait at most 20 seconds for completion */ int i = 0; int ret; device_id = wifi_get_device_id(); // 通过设备的VID和设备的PID 确定设备的 index if (WIFI_INVALID_DEVICE == device_id) &#123; ALOGE("Cannot find supported device"); return -1; &#125; ALOGE("load wifi driver module id:%d",device_id); /* MT7603U and MT7632U and RTK8812AU needs pre-alloc memory firstly, * don't unload it when close WiFi */ if (WIFI_MEDIATEK_MT7603U == device_id || WIFI_MEDIATEK_MT7632U == device_id || WIFI_MEDIATEK_MT7662U == device_id || WIFI_MEDIATEK_MT7601U == device_id || WIFI_REALTEK_RTL8821AU == device_id ) &#123; if (load_prealloc_module(device_id)) &#123; // 进行一些预先的驱动挂载 ALOGE("Cannot load prealloc module"); return -1; &#125; &#125; if (is_wifi_driver_loaded(mode)) //判断驱动是否已经完成加载 return 0; for (i = 0; i &lt; mode_drivers[device_id].module_num; i++) &#123; ret = is_module_loaded(mode_drivers[device_id].modules[i].module_name); if(1 == ret)&#123; if (insmod(mode_drivers[device_id].modules[i].module_path, \ mode_drivers[device_id].modules[i].module_arg) &lt; 0)&#123; // insmod Wifi modules ALOGE("wifi load driver %s error!",mode_drivers[device_id].modules[i].module_path); return -1; &#125; &#125;else if(0 == ret)&#123; ALOGI("wifi module %s has loaded!",mode_drivers[device_id].modules[i].module_name); &#125;else&#123; ALOGE("check wifi module %s status error!",mode_drivers[device_id].modules[i].module_name); &#125; &#125; if (strcmp(FIRMWARE_LOADER,"") == 0) &#123; /* usleep(WIFI_DRIVER_LOADER_DELAY); */ property_set(DRIVER_PROP_NAME, "ok"); &#125; else &#123; property_set("ctl.start", FIRMWARE_LOADER); &#125; sched_yield(); while (count-- &gt; 0) &#123; if (property_get(DRIVER_PROP_NAME, driver_status, NULL)) &#123; if (strcmp(driver_status, "ok") == 0) return 0; else if (strcmp(DRIVER_PROP_NAME, "failed") == 0) &#123; wifi_unload_driver(mode); return -1; &#125; &#125; usleep(200000); &#125; property_set(DRIVER_PROP_NAME, "timeout"); wifi_unload_driver(mode); return -1;#else property_set(DRIVER_PROP_NAME, "ok"); return 0;#endif&#125; 此处进行驱动的识别和加载 加载成功后，setWifiApState(WIFI_AP_STATE_ENABLING); 发送广播告知当前AP状态，然后transitionTo(mSoftApStartingState);将wifistatemachine的状态切换到mSoftApStartingState，我们来看一下他的enter函数12345678910111213141516171819//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javaclass SoftApStartingState extends State &#123; @Override public void enter() &#123; final Message message = getCurrentMessage(); if (message.what == CMD_START_AP) &#123; final WifiConfiguration config = (WifiConfiguration) message.obj; if (config == null) &#123;//如果传入config是空的，则发出请求Ap的config mWifiApConfigChannel.sendMessage(CMD_REQUEST_AP_CONFIG); &#125; else &#123;//如果传入config是已存在，则发出请求Ap配置需要写入到配置中并生效 mWifiApConfigChannel.sendMessage(CMD_SET_AP_CONFIG, config); startSoftApWithConfig(config); &#125; &#125; else &#123; throw new RuntimeException("Illegal transition to SoftApStartingState: " + message); &#125; &#125;&#125; 我们看一下config为null的情况12345678910111213141516171819//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiApConfigStore.java class DefaultState extends State &#123; public boolean processMessage(Message message) &#123; switch (message.what) &#123; case WifiStateMachine.CMD_SET_AP_CONFIG: case WifiStateMachine.CMD_SET_AP_CONFIG_COMPLETED: Log.e(TAG, "Unexpected message: " + message); break; case WifiStateMachine.CMD_REQUEST_AP_CONFIG: mReplyChannel.replyToMessage(message, WifiStateMachine.CMD_RESPONSE_AP_CONFIG, mWifiApConfig);//消息处理回传 CMD_RESPONSE_AP_CONFIG break; default: Log.e(TAG, "Failed to handle " + message); break; &#125; return HANDLED; &#125; &#125; 此时会回应消息到WifiStateMachine并将mWifiApConfig传递1234567891011121314//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javaclass SoftApStartingState extends State &#123; public boolean processMessage(Message message) &#123; case WifiStateMachine.CMD_RESPONSE_AP_CONFIG: WifiConfiguration config = (WifiConfiguration) message.obj;//取出默认配置 if (config != null) &#123; startSoftApWithConfig(config); //开始配置并且启动 &#125; else &#123; loge("Softap config is null!"); sendMessage(CMD_START_AP_FAILURE); &#125; break; &#125;&#125; 取出Ap的配置然后开始进行进行配置启动1234567891011121314151617181920212223//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java private void startSoftApWithConfig(final WifiConfiguration config) &#123; // Start hostapd on a separate thread new Thread(new Runnable() &#123; public void run() &#123; try &#123; mNwService.startAccessPoint(config, mInterfaceName); &#125; catch (Exception e) &#123; loge("Exception in softap start " + e); try &#123; mNwService.stopAccessPoint(mInterfaceName); mNwService.startAccessPoint(config, mInterfaceName); &#125; catch (Exception e1) &#123; loge("Exception in softap re-start " + e1); sendMessage(CMD_START_AP_FAILURE); return; &#125; &#125; if (DBG) log("Soft AP start successful"); sendMessage(CMD_START_AP_SUCCESS); &#125; &#125;).start(); &#125; 开始AP的加载 NwService.startAccessPoint（）123456789101112131415161718//Android/frameworks/base/services/core/java/com/android/server/NetworkManagementService.javapublic void startAccessPoint( WifiConfiguration wifiConfig, String wlanIface) &#123; mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG); try &#123; wifiFirmwareReload(wlanIface, "AP"); if (wifiConfig == null) &#123;//逻辑上不为空 mConnector.execute("softap", "set", wlanIface); &#125; else &#123;//softap set mConnector.execute("softap", "set", wlanIface, wifiConfig.SSID, "broadcast", "6", getSecurityType(wifiConfig), new SensitiveArg(wifiConfig.preSharedKey)); &#125; mConnector.execute("softap", "startap"); // startAP &#125; catch (NativeDaemonConnectorException e) &#123; throw e.rethrowAsParcelableException(); &#125;&#125; 将cmd发送给commandlistener 1234567891011121314151617181920212223242526272829303132333435363738394041//system/netd/server/CommandListener.cppint CommandListener::SoftapCmd::runCommand(SocketClient *cli,int argc, char **argv) &#123; int rc = ResponseCode::SoftapStatusResult; char *retbuf = NULL; if (sSoftapCtrl == NULL) &#123; cli-&gt;sendMsg(ResponseCode::ServiceStartFailed, "SoftAP is not available", false); return -1; &#125; if (argc &lt; 2) &#123; cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Missing argument in a SoftAP command", false); return 0; &#125; if (!strcmp(argv[1], "startap")) &#123; rc = sSoftapCtrl-&gt;startSoftap(); //mConnector.execute("softap", "startap"); &#125; else if (!strcmp(argv[1], "stopap")) &#123; rc = sSoftapCtrl-&gt;stopSoftap(); &#125; else if (!strcmp(argv[1], "fwreload")) &#123; rc = sSoftapCtrl-&gt;fwReloadSoftap(argc, argv); &#125; else if (!strcmp(argv[1], "status")) &#123; asprintf(&amp;retbuf, "Softap service %s running", (sSoftapCtrl-&gt;isSoftapStarted() ? "is" : "is not")); cli-&gt;sendMsg(rc, retbuf, false); free(retbuf); return 0; &#125; else if (!strcmp(argv[1], "set")) &#123; rc = sSoftapCtrl-&gt;setSoftap(argc, argv); //mConnector.execute("softap", "set", wlanIface, wifiConfig.SSID,"broadcast", "6", getSecurityType(wifiConfig),new SensitiveArg(wifiConfig.preSharedKey)); &#125; else &#123; cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, "Unrecognized SoftAP command", false); return 0; &#125; if (rc &gt;= 400 &amp;&amp; rc &lt; 600) cli-&gt;sendMsg(rc, "SoftAP command has failed", false); else cli-&gt;sendMsg(rc, "Ok", false); return 0;&#125; 执行 setSoftap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Android/system/netd/server/SoftapController.cppstatic const char HOSTAPD_CONF_FILE[] = "/data/misc/wifi/hostapd.conf";int SoftapController::setSoftap(int argc, char *argv[]) &#123; char psk_str[2*SHA256_DIGEST_LENGTH+1]; int ret = ResponseCode::SoftapStatusResult; int fd; int hidden = 0; int channel = AP_CHANNEL_DEFAULT; char *wbuf = NULL; char *fbuf = NULL; if (argc &lt; 5) &#123; ALOGE("Softap set is missing arguments. Please use:"); ALOGE("softap &lt;wlan iface&gt; &lt;SSID&gt; &lt;hidden/broadcast&gt; &lt;channel&gt; &lt;wpa2?-psk|open&gt; &lt;passphrase&gt;"); return ResponseCode::CommandSyntaxError; &#125; if (!strcasecmp(argv[4], "hidden")) hidden = 1; if (argc &gt;= 5) &#123; channel = atoi(argv[5]); if (channel &lt;= 0) channel = AP_CHANNEL_DEFAULT; &#125; asprintf(&amp;wbuf, "interface=%s\ndriver=nl80211\nctrl_interface=" "/data/misc/wifi/hostapd\nssid=%s\nchannel=%d\nieee80211n=1\n" "hw_mode=g\nht_capab=[SHORT-GI-20][SHORT-GI-40][HT40+]\nignore_broadcast_ssid=%d\nwowlan_triggers=any\n", argv[2], argv[3], channel, hidden); if (argc &gt; 7) &#123; if (!strcmp(argv[6], "wpa-psk")) &#123; generatePsk(argv[3], argv[7], psk_str); asprintf(&amp;fbuf, "%swpa=1\nwpa_pairwise=TKIP CCMP\nwpa_psk=%s\n", wbuf, psk_str); &#125; else if (!strcmp(argv[6], "wpa2-psk")) &#123; generatePsk(argv[3], argv[7], psk_str); asprintf(&amp;fbuf, "%swpa=2\nrsn_pairwise=CCMP\nwpa_psk=%s\n", wbuf, psk_str); &#125; else if (!strcmp(argv[6], "open")) &#123; asprintf(&amp;fbuf, "%s", wbuf); &#125; &#125; else if (argc &gt; 6) &#123; if (!strcmp(argv[6], "open")) &#123; asprintf(&amp;fbuf, "%s", wbuf); &#125; &#125; else &#123; asprintf(&amp;fbuf, "%s", wbuf); &#125; fd = open(HOSTAPD_CONF_FILE, O_CREAT | O_TRUNC | O_WRONLY | O_NOFOLLOW, 0660); if (fd &lt; 0) &#123; ALOGE("Cannot update \"%s\": %s", HOSTAPD_CONF_FILE, strerror(errno)); free(wbuf); free(fbuf); return ResponseCode::OperationFailed; &#125; if (write(fd, fbuf, strlen(fbuf)) &lt; 0) &#123; ALOGE("Cannot write to \"%s\": %s", HOSTAPD_CONF_FILE, strerror(errno)); ret = ResponseCode::OperationFailed; &#125; free(wbuf); free(fbuf); /* Note: apparently open can fail to set permissions correctly at times */ if (fchmod(fd, 0660) &lt; 0) &#123; ALOGE("Error changing permissions of %s to 0660: %s", HOSTAPD_CONF_FILE, strerror(errno)); close(fd); unlink(HOSTAPD_CONF_FILE); return ResponseCode::OperationFailed; &#125; if (fchown(fd, AID_SYSTEM, AID_WIFI) &lt; 0) &#123; ALOGE("Error changing group ownership of %s to %d: %s", HOSTAPD_CONF_FILE, AID_WIFI, strerror(errno)); close(fd); unlink(HOSTAPD_CONF_FILE); return ResponseCode::OperationFailed; &#125; close(fd); return ret;&#125; 这里进行启动配置文件 “/data/misc/wifi/hostapd.conf” 的创建（不是客户配置文件） 然后startsoftap12345678910111213141516171819202122232425262728293031323334353637//Android/system/netd/server/SoftapController.cppstatic const char HOSTAPD_CONF_FILE[] = "/data/misc/wifi/hostapd.conf";static const char HOSTAPD_BIN_FILE[] = "/system/bin/hostapd";#define WIFI_ENTROPY_FILE "/data/misc/wifi/entropy.bin"int SoftapController::startSoftap() &#123; pid_t pid = 1; if (mPid) &#123; ALOGE("SoftAP is already running"); return ResponseCode::SoftapStatusResult; &#125; if (ensure_entropy_file_exists() &lt; 0) &#123; ALOGE("Wi-Fi entropy file was not created"); &#125; if ((pid = fork()) &lt; 0) &#123; ALOGE("fork failed (%s)", strerror(errno)); return ResponseCode::ServiceStartFailed; &#125; if (!pid) &#123; ensure_entropy_file_exists(); if (execl(HOSTAPD_BIN_FILE, HOSTAPD_BIN_FILE, "-e", WIFI_ENTROPY_FILE, HOSTAPD_CONF_FILE, (char *) NULL)) &#123; //启动softap ALOGE("execl failed (%s)", strerror(errno)); &#125; ALOGE("SoftAP failed to start"); return ResponseCode::ServiceStartFailed; &#125; else &#123; mPid = pid; ALOGD("SoftAP started successfully"); usleep(AP_BSS_START_DELAY); &#125; return ResponseCode::SoftapStatusResult;&#125; 启动后，回到wifistatemachine1234567891011121314151617181920212223//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java private void startSoftApWithConfig(final WifiConfiguration config) &#123; // Start hostapd on a separate thread new Thread(new Runnable() &#123; public void run() &#123; try &#123; mNwService.startAccessPoint(config, mInterfaceName); &#125; catch (Exception e) &#123; loge("Exception in softap start " + e); try &#123; mNwService.stopAccessPoint(mInterfaceName); mNwService.startAccessPoint(config, mInterfaceName); &#125; catch (Exception e1) &#123; loge("Exception in softap re-start " + e1); sendMessage(CMD_START_AP_FAILURE); return; &#125; &#125; if (DBG) log("Soft AP start successful"); sendMessage(CMD_START_AP_SUCCESS); //发送消息 启动AP成功 &#125; &#125;).start(); &#125; 向状态机发送 CMD_START_AP_SUCCESS12345678910//Android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.javaclass SoftApStartingState extends State &#123; public boolean processMessage(Message message) &#123; case CMD_START_AP_SUCCESS: setWifiApState(WIFI_AP_STATE_ENABLED); transitionTo(mSoftApStartedState); break; &#125;&#125; 发送广播，AP已经设置，将状态切到mSoftApStartedState此时，这个原生ap，就启动成功了]]></content>
      <categories>
        <category>Android netd</category>
      </categories>
      <tags>
        <tag>Android softap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux init.rc Service Name 过长导致服务不可用的问题]]></title>
    <url>%2F2017%2F06%2F04%2Finit_rc_servername_too_long%2F</url>
    <content type="text"><![CDATA[linux init.rc service name 过长导致服务不可用的问题 前段时间在处理一网通问题的时候，遇到了一个很匪夷所思的问题：在init.xxx.rc中增加了一个service，内容是运行一个脚本，编译烧录内核以后，发现这个service 就是不会执行，无论怎么调换位置和格式，就是不能执行，当时的内容如下：123service flush_dns_nameserver /system/bin/flush_dns_name.sh ... ... 网上查了一些资料，也没有发现相关的现象。在进行了很多尝试都没有奏效后，我将service name的长度缩短了一点，缩短成下面这样123service flush_service /system/bin/flush_dns_name.sh ... ... 竟然奇迹的可以了！！！ 看样子linux在这里做了手脚，我们来看看源码: 12345678910111213141516171819202122232425262728293031323334static void *parse_service(struct parse_state *state, int nargs, char **args)&#123; struct service *svc; if (nargs &lt; 3) &#123; parse_error(state, "services must have a name and a program\n"); return 0; &#125; if (!valid_name(args[1])) &#123; parse_error(state, "invalid service name '%s'\n", args[1]); return 0; &#125; svc = service_find_by_name(args[1]); if (svc) &#123; parse_error(state, "ignored duplicate definition of service '%s'\n", args[1]); return 0; &#125; nargs -= 2; svc = calloc(1, sizeof(*svc) + sizeof(char*) * nargs); if (!svc) &#123; parse_error(state, "out of memory\n"); return 0; &#125; svc-&gt;name = args[1]; svc-&gt;classname = "default"; memcpy(svc-&gt;args, args + 2, sizeof(char*) * nargs); svc-&gt;args[nargs] = 0; svc-&gt;nargs = nargs; svc-&gt;onrestart.name = "onrestart"; list_init(&amp;svc-&gt;onrestart.commands); list_add_tail(&amp;service_list, &amp;svc-&gt;slist); return svc;&#125; 上面的内容是init_parser.c的函数，作用是解析开机启动脚本（init.xxx.rc）的service section内容。在解析之前，函数进行了一个参数检测 1234if (!valid_name(args[1])) &#123; parse_error(state, "invalid service name '%s'\n", args[1]); return 0;&#125; args[1] 也就是service name 这里对service name 进行了一个valid判断12345678910111213static int valid_name(const char *name)&#123; if (strlen(name) &gt; 16) &#123; return 0; &#125; while (*name) &#123; if (!isalnum(*name) &amp;&amp; (*name != '_') &amp;&amp; (*name != '-')) &#123; return 0; &#125; name++; &#125; return 1;&#125; 通过原生的代码，我们可以得出一下结论： service name 长度不能超出16个字符 service name 命名时可以使用的字符只能是字母数字（0-9a-zA-Z），’_’和 ‘-‘ 因为连续两天有人踩了这个坑，决定追一下源码，填了这个坑]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux init.rc</tag>
      </tags>
  </entry>
</search>